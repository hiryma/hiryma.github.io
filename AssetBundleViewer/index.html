<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>AssetBundleViewer</title>
</head>

<body id="body">
	<h1>AssetBundleViewer</h1>
	<h2>入力</h2>
	<input type="file" id="file" name="file">
	<h2>結果</h2>
	<table border="1" id="table">
		<tr>
			<td>アセットの名前がここに出る
	</table>

	<h2>これは何か</h2>
	<p>
		UnityEditorを持っていない人でも、AssetBundleファイルに何が入っているかが見られるツール
	</p>

	<h2>使い方</h2>
	<p>
		AssetBundleファイルをドロップするか、上の「ファイルを選択」ボタンでファイルを選ぶ
	</p>

	<h2>実装済み機能</h2>
	<ul>
		<li>パスっぽい文字列を見つけて出すだけ
	</ul>

	<h2>既知の不具合</h2>
	<ul>
		<li>アセットパスらしきものを抜いているだけなので、ピリオドやスラッシュがほどよく混ざっていると変なものもパスとして表示してしまう
		<li>日本語やスペース混ざりのファイル名はパス扱いされず出ない
	</ul>

	<h2>そのうち作りたい機能</h2>
	<ul>
		<li>electron?でデスクトップアプリ化
		<li>ちゃんと解釈して名前が入っているとわかっている所を抜き出したい
		<li>中に入っているデータの詳細をちゃんと表示した。例えば画像の解像度やフィルタ設定等
		<li>画像は可能ならブラウザ上に表示したい
	</ul>

	<hr>

	<h2>実装メモ</h2>
	<ul>
		<li>元ネタは<a href="https://github.com/AnemoneStar/shibunyan">shibunyan</a>だが、面倒くさくなって解釈を途中までしかやっていない
		<li>AssetBundleの内部formatが上がった時に解析と対応作業が必要になるので、こういうものを自作するのは本来良くない
		<li>LZ4は<a href="https://github.com/pierrec/node-lz4">pierrec/node-lz4</a>を使っているが、そのままだとブラウザで動かなかったので、よくわからないまま一部いじっている。
	</ul>

	<h2>デバグ</h2>
	<a id="download" download="uncompressed.bin">[download uncompressed binary]</a>
</body>

<script type="text/javascript" src="lz4.js"></script>
<script>
	var Buffer = require('buffer').Buffer;
	var LZ4 = require('1');
	(function main() {
		"use strict";
		//BinaryReaderクラス定義 BigEndian固定
		var BinaryReader = function (arrayBuffer, offset) {
			if (typeof offset === 'undefined') {
				this.mPosition = 0;
			} else {
				this.mPosition = offset;
			}
			this.mBytes = new Uint8Array(arrayBuffer);
			this.mIsLittleEndian = false;
		};
		BinaryReader.prototype.setIsLittleEndian = function (isLittleEndian) {
			this.mIsLittleEndian = isLittleEndian;
		}
		BinaryReader.prototype.getBytes = function () {
			return this.mBytes;
		};
		BinaryReader.prototype.getPosition = function () {
			return this.mPosition;
		};
		BinaryReader.prototype.setPosition = function (position) {
			console.assert(position <= this.mBytes.length);
			this.mPosition = position;
		};
		BinaryReader.prototype.skip = function (length) {
			console.assert((this.mPosition + length) <= this.mBytes.length);
			this.mPosition += length;
		};
		BinaryReader.prototype.align = function (align) {
			this.mPosition = (this.mPosition + align - 1) & ~(align - 1);
		};
		BinaryReader.prototype.getU1 = function () {
			console.assert((this.mPosition + 1) <= this.mBytes.length);
			var ret = this.mBytes[this.mPosition];
			this.mPosition++;
			return ret;
		};
		BinaryReader.prototype.getU2 = function () {
			console.assert((this.mPosition + 2) <= this.mBytes.length);
			var ret = 0;
			if (this.mIsLittleEndian) {
				ret |= this.mBytes[this.mPosition + 1] << 8;
				ret |= this.mBytes[this.mPosition + 0];
			} else {
				ret |= this.mBytes[this.mPosition + 0] << 8;
				ret |= this.mBytes[this.mPosition + 1];
			}
			this.mPosition += 2;
			return ret;
		};
		BinaryReader.prototype.getU4 = function () {
			console.assert((this.mPosition + 4) <= this.mBytes.length);
			var ret = 0;
			if (this.mIsLittleEndian) {
				ret |= this.mBytes[this.mPosition + 3] << 24;
				ret |= this.mBytes[this.mPosition + 2] << 16;
				ret |= this.mBytes[this.mPosition + 1] << 8;
				ret |= this.mBytes[this.mPosition + 0];
			} else {
				ret |= this.mBytes[this.mPosition + 0] << 24;
				ret |= this.mBytes[this.mPosition + 1] << 16;
				ret |= this.mBytes[this.mPosition + 2] << 8;
				ret |= this.mBytes[this.mPosition + 3];
			}
			this.mPosition += 4;
			return ret;
		};
		BinaryReader.prototype.getU8Low = function () {
			console.assert((this.mPosition + 8) <= this.mBytes.length);
			var ret = 0;
			if (this.mIsLittleEndian) {
				ret = this.getU4();
				var high = this.getU4();
				console.assert(high === 0, "getU8Low() high is not zero. " + high);
			} else {
				var high = this.getU4();
				console.assert(high === 0, "getU8Low() high is not zero. " + high);
				ret = this.getU4();
			}
			return ret;
		};
		BinaryReader.prototype.getU8AsHexNumber = function () {
			console.assert((this.mPosition + 8) <= this.mBytes.length);
			var ret = "";
			var i, byte;
			if (this.mIsLittleEndian) {
				for (i = 7; i >= 0; i--) {
					byte = this.mBytes[this.mPosition + i];
					ret += String.fromCharCode(this.toHex(byte >> 4));
					ret += String.fromCharCode(this.toHex(byte & 0xf));
				}
			} else {
				for (i = 0; i < 8; i++) {
					byte = this.mBytes[this.mPosition + i];
					ret += String.fromCharCode(this.toHex(byte >> 4));
					ret += String.fromCharCode(this.toHex(byte & 0xf));
				}
			}
			this.mPosition += 8;
			return ret;
		};
		BinaryReader.prototype.toHex = function (x) {
			var code;
			switch (x) {
				case 0: code = 48; break;
				case 1: code = 49; break;
				case 2: code = 50; break;
				case 3: code = 51; break;
				case 4: code = 52; break;
				case 5: code = 53; break;
				case 6: code = 54; break;
				case 7: code = 55; break;
				case 8: code = 56; break;
				case 9: code = 57; break;
				case 10: code = 65; break;
				case 11: code = 66; break;
				case 12: code = 67; break;
				case 13: code = 68; break;
				case 14: code = 69; break;
				case 15: code = 70; break;
			}
			return code;
		}
		BinaryReader.prototype.readAsHexNumber = function (length) {
			console.assert((this.mPosition + length) <= this.mBytes.length);
			var out, i, byte, c;
			out = "";
			for (i = 0; i < length; i++) {
				byte = this.mBytes[this.mPosition + i];
				out += String.fromCharCode(this.toHex(byte >> 4));
				out += String.fromCharCode(this.toHex(byte & 0xf));
			}
			this.mPosition += length;
			return out;
		};
		BinaryReader.prototype.getString = function () {
			var out, c0, c1, c2;
			out = "";
			while (this.mPosition < this.mBytes.length) {
				c0 = this.mBytes[this.mPosition];
				this.mPosition++;
				if (c0 === 0) {
					break;
				}
				switch (c0 >> 4) {
					case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
						// 0xxxxxxx
						out += String.fromCharCode(c0);
						break;
					case 12: case 13:
						// 110x xxxx   10xx xxxx
						c1 = this.mBytes[this.mPosition];
						this.mPosition++;
						out += String.fromCharCode(((c0 & 0x1F) << 6) | (c1 & 0x3F));
						break;
					case 14:
						// 1110 xxxx  10xx xxxx  10xx xxxx
						c1 = this.mBytes[this.mPosition];
						c2 = this.mBytes[this.mPosition + 1];
						this.mPosition += 2;
						out += String.fromCharCode(((c0 & 0x0F) << 12) |
							((c1 & 0x3F) << 6) |
							((c2 & 0x3F) << 0));
						break;
				}
			}
			return out;
		};
		BinaryReader.prototype.uncompressLz4 = function (
			compressedSize,
			uncompressedSize,
			flags) {
			if ((typeof compressedSize === 'undefined') &&
				(typeof uncompressedSize === 'undefined') &&
				(typeof flags === 'undefined')) {
				compressedSize = this.getU4();
				uncompressedSize = this.getU4();
				flags = this.getU4();
			}
			var i;

			//			alert('flags: ' + flags + '\n' + 'compressedSize: ' + compressedSize + '\n' + 'uncompressedSize: ' + uncompressedSize + '\n');

			var compressedUint8Array = this.mBytes.slice(
				this.mPosition,
				this.mPosition + compressedSize);
			var inputBuffer = new Buffer(compressedUint8Array.length);
			for (i = 0; i < compressedSize; i++) {
				inputBuffer[i] = compressedUint8Array[i];
			}
			var outputBuffer = new Buffer(uncompressedSize);
			var written = LZ4.uncompress(
				inputBuffer,
				outputBuffer);
			console.assert(written === uncompressedSize);
			var uncompressedArrayBuffer = new ArrayBuffer(uncompressedSize);
			var uncompressedUint8Array = new Uint8Array(uncompressedArrayBuffer);
			for (i = 0; i < uncompressedSize; i++) {
				uncompressedUint8Array[i] = outputBuffer[i];
			}
			var outputReader = new BinaryReader(uncompressedArrayBuffer);
			this.mPosition += compressedSize;
			return outputReader;
		};
		var reader = new FileReader();
		reader.onload = function (event) {
			var arrayBuffer = event.target.result;
			var bytes = new Uint8Array(arrayBuffer);
			var reader = new BinaryReader(bytes);
			processAssetBundle(reader);
		};
		reader.onabort = function (file) {
			alert(file.name + ' aboarted.');
		};
		var onFileSelect = function (e) {
			var file = e.target.files[0];
			reader.readAsArrayBuffer(file);
		};
		var onDragOver = function (e) {
			e.stopPropagation();
			e.preventDefault();
			e.dataTransfer.dropEffect = 'copy';
		};
		var onDrop = function (e) {
			e.stopPropagation();
			e.preventDefault();
			if (e.dataTransfer.files.length > 0) {
				var file = e.dataTransfer.files[0];
				reader.readAsArrayBuffer(file);
			}
		};
		document.getElementById('file').addEventListener('change', onFileSelect, false);
		document.getElementById('body').addEventListener('dragover', onDragOver, false);
		document.getElementById('body').addEventListener('drop', onDrop, false);

		var processAssetBundle = function (reader) {
			var signiture = reader.getString();
			var format = reader.getU4();
			var unityVersion = reader.getString();
			var generatorVersion = reader.getString();

			if (signiture !== 'UnityFS') {
				alert("UnityFS以外非対応ごめん!");
				return;
			}

			var fileSize = reader.getU8Low();
			console.log('signiture: ' + signiture + '\nformat: ' + format + '\nunityVersion: ' + unityVersion + '\ngeneratorVersion: ' + generatorVersion + '\nfileSize: ' + fileSize + '\n');

			var headerReader = reader.uncompressLz4();
			var guid = headerReader.readAsHexNumber(16);
			//			alert('guid: ' + guid);
			var blockCount = headerReader.getU4();
			var blocks = [];
			var i;
			var uncompressedSizeSum = 0;
			for (i = 0; i < blockCount; i++) {
				var uncompressedSize = headerReader.getU4();
				uncompressedSizeSum += uncompressedSize;
				var compressedSize = headerReader.getU4();
				var flags = headerReader.getU2();
				var block = {
					uncompressedSize: uncompressedSize,
					compressedSize: compressedSize,
					flags: flags
				};
				//alert(block.uncompressedSize + " " + block.compressedSize + " " + block.flags);
				blocks.push(block);
			}
			var assetBlocks = [];
			var assetBlockCount = headerReader.getU4();
			for (i = 0; i < assetBlockCount; i++) {
				var offset = headerReader.getU8Low();
				var size = headerReader.getU8Low();
				var status = headerReader.getU4();
				var name = headerReader.getString();
				var assetBlock = {
					offset: offset,
					size: size,
					status: status,
					name: name
				};
				//				alert("asset: " + offset + " " + size + " " + status + " " + name);
				assetBlocks.push(assetBlock);
			}

			// 全展開する。マジで?アセットごとに別ブロックなんじゃないの?思ったのと違うよ?
			var bodyBytes = new Uint8Array(uncompressedSizeSum);
			var bodyBytePos = 0;
			for (i = 0; i < blockCount; i++) {
				var blockReader = reader.uncompressLz4(
					blocks[i].compressedSize,
					blocks[i].uncompressedSize,
					blocks[i].flags);
				var blockBytes = blockReader.getBytes();
				var blockLength = blockBytes.length;
				bodyBytes.set(blockBytes, bodyBytePos);
				bodyBytePos += blockLength;
			}
			// バイナリ保存
			var blob = new Blob([bodyBytes]);
			var url = URL.createObjectURL(blob);
			document.getElementById('download').setAttribute('href', url);

			// 文字列化
			var strings = extractStrings(bodyBytes);
			// ここからパスくさいのを探す
			var table = document.getElementById('table');
			while (table.firstChild) { // 掃除
				table.removeChild(table.firstChild);
			}
			for (i = 0; i < strings.length; i++) {
				if (isPath(strings[i])) {
					console.log('path: ' + strings[i]);

					var tr = document.createElement('tr');
					var td = document.createElement('td');
					td.innerText = strings[i];
					tr.appendChild(td);
					table.appendChild(tr);
				}
			}
			return;

			// アセット展開
			var assets = [];
			for (i = 0; i < assetBlockCount; i++) {
				var assetReader = new BinaryReader(bodyBytes, assetBlocks[i].offset);
				var asset = processAsset(assetReader);
				assets.push(asset);
			}
		};
		var isPath = function (str) {
			// [a-zA-Z0-9_./]のみで構成されていればtrueを返す
			var i, c, ok;
			var periodExists = false;
			var slashExists = false;
			for (i = 0; i < str.length; i++) {
				c = str.charCodeAt(i);
				var isSmall = (c >= 'a'.charCodeAt(0)) && (c <= 'z'.charCodeAt(0));
				var isBig = (c >= 'A'.charCodeAt(0)) && (c <= 'Z'.charCodeAt(0));
				var isDigit = (c >= '0'.charCodeAt(0)) && (c <= '9'.charCodeAt(0));
				var tmpPeriodExists = (c === '.'.charCodeAt(0));
				var tmpSlashExists = (c === '/'.charCodeAt(0));
				var isOtherValid = (c === '_'.charCodeAt(0));
				if (tmpPeriodExists) {
					periodExists = true;
				}
				if (tmpSlashExists) {
					slashExists = true;
				}
				if (!isSmall && !isBig && !isDigit && !tmpPeriodExists && !tmpSlashExists && !isOtherValid) {
					return false;
				}
			}
			return periodExists && slashExists; // ピリオドとスラッシュが最低一個はないとパスとは認めないが例外はありそうだなあ
		};
		var extractStrings = function (bytes) {
			var c0, c1, c2, c3;
			var ret = [];
			var str = "";
			var i = 0;
			while (i < bytes.length) {
				c0 = bytes[i];
				if ((i + 1) < bytes.length) {
					c1 = bytes[i + 1];
				} else {
					c1 = 0;
				}
				if ((i + 2) < bytes.length) {
					c2 = bytes[i + 2];
				} else {
					c2 = 0;
				}
				if ((i + 3) < bytes.length) {
					c3 = bytes[i + 3];
				} else {
					c3 = 0;
				}

				if (c0 < 0x20) { // 制御文字とみなして文字列終了
					if (str.length > 0) {
						ret.push(str);
						str = "";
					}
					i += 1;
				} else if (c0 < 0x80) { // 通常ASCII
					str += String.fromCharCode(c0);
					i += 1;
				} else if (c0 < 0xc2) { // 二文字目以降のはず。UTF8ならありえないが、バイナリならありうるので、とりあえず文字列終了
					if (str.length > 0) {
						ret.push(str);
						str = "";
					}
					i += 1;
				} else if (c0 < 0xe0) { // 2バイト文字
					str += String.fromCharCode(((c0 & 0x1F) << 6) | (c1 & 0x3F));
					i += 2;
				} else if (c0 < 0xf0) { // 3バイト文字
					str += String.fromCharCode(((c0 & 0x0F) << 12) |
						((c1 & 0x3F) << 6) |
						((c2 & 0x3F) << 0));
					i += 3;
				} else if (c0 < 0xf8) { // 4バイト文字
					str += String.fromCharCode(((c0 & 0x07) << 18) |
						((c1 & 0x3F) << 12) |
						((c2 & 0x3F) << 6) |
						((c3 & 0x3F) << 0));
					i += 4;
				} else { // UTF-8ではありえないので1文字飛ばす
					if (str.length > 0) {
						ret.push(str);
						str = "";
					}
					i += 1;
				}
			}
			return ret;
		};
		var processAsset = function (reader) {
			var metadataSize = reader.getU4();
			var size = reader.getU4();
			var format = reader.getU4();
			var offset = reader.getU4();
			var i;
			if (format >= 9) {
				var endian = reader.getU4();
				reader.setIsLittleEndian(endian === 0); // 0ならリトルエンディアン
			}
			var generatorVersion = reader.getString();
			var targetPlatform = reader.getU4();
			console.log('[assset]\nmetadataSize: ' + metadataSize + '\n' + 'size: ' + size + '\n' + 'format: ' + format + '\n' + 'offset: ' + offset + '\n' + 'generatorVersion: ' + generatorVersion + '\n' + 'targetPlatform: ' + targetPlatform + '\n');
			var assetTypes = [];
			if (format >= 17) {
				var hasTypeTreeFlag = reader.getU1();
				var hasTypeTrees = (hasTypeTreeFlag !== 0);
				var typeCount = reader.getU4();
				console.log('hasTypeTreeFlag: ' + hasTypeTreeFlag + '\nhasTypeTrees: ' + hasTypeTrees + '\ntypeCount: ' + typeCount);
				for (i = 0; i < typeCount; i++) {
					var type = {};
					type.classId = reader.getU4();
					reader.skip(1);
					type.scriptId = reader.getU2();
					type.hash = ((type.classId & 0x80000000) || (type.classId == 114)) ? reader.readAsHexNumber(32) : reader.readAsHexNumber(16);
					console.log('classId: ' + type.classId + '\nscriptId: ' + type.scriptId + '\nhash: ' + type.hash);
					if (hasTypeTrees) {
						type.typeTree = processTypeTree(reader);
					}
					assetTypes.push(type);
				}
			} else if (format >= 13) {
				var hasTypeTreeFlag = reader.getU1();
				var hasTypeTrees = (hasTypeTreeFlag !== 0);
				var typeCount = reader.getU4();
				console.log('hasTypeTreeFlag: ' + hasTypeTreeFlag + '\nhasTypeTrees: ' + hasTypeTrees + '\ntypeCount: ' + typeCount);
				for (i = 0; i < typeCount; i++) {
					var type = {};
					type.classId = reader.getU4();
					type.hash = (type.classId & 0x80000000) ? reader.readAsHexNumber(32) : reader.readAsHexNumber(16);
					console.log('classId: ' + type.classId + '\nhash: ' + type.hash);
					if (hasTypeTrees) {
						type.typeTree = processTypeTree(reader);
					}
					assetTypes.push(type);
				}
			}
			var objectIdIsLong = (format >= 14) ||
				((format >= 7) && (format <= 13) && (reader.getU4() !== 0));
			var objects = [];
			var objectCount = reader.getU4();
			console.log('objectIdIsLong: ' + objectIdIsLong + '\nobjectCount: ' + objectCount);
			for (i = 0; i < objectCount; i++) {
				var object = {};
				if (format >= 14) {
					reader.align(4);
				}
				object.pathId = objectIdIsLong ? reader.getU8AsHexNumber() : reader.getU4();
				object.offset = reader.getU4();
				object.size = reader.getU4();
				console.log('pathId: ' + object.pathId + '\noffset: ' + object.offset + '\nsize: ' + object.size);

				object.destroyed = false;
				if (format >= 17) {
					object.classIndex = reader.getU4();
					object.typeId = null;
					objet.classId = null;
				} else {
					object.clasIndex = null;
					object.typeId = reader.getU4();
					object.classId = reader.getU2();
					if (format <= 10) {
						object.destroyed = (reader.getU2() !== 0);
					}
				}
				if ((format >= 11) && (format <= 16)) {
					reader.skip(2);
				}
				if ((format >= 15) && (format <= 16)) {
					reader.skip(1);
				}
				var posBack = reader.getPosition();
				reader.setPosition(offset + object.offset);
				console.log('[object]\nasset_offset: ' + (offset + object.offset) + '\nsize: ' + object.size);
				objects.value = processObjectValue(reader);
				reader.skip(object.size); // とりあえず読み捨て
				reader.setPosition(posBack);
			}

			var addIds = [];
			if (format >= 11) {
				var idCount = reader.getU4()
				console.log('idCount: ' + idCount);
				for (i = 0; i < idCount; i++) {
					if (format >= 14) {
						reader.align(4);
					}
					addIds.push([objectIdIsLong ? reader.getU8AsHexNumber() : reader.getU4(), reader.getU4()]);
				}
			}

			var reerences = [];
			if (format >= 6) {
				var referenceCount = reader.getU4();
				console.log('referenceCount: ' + referenceCount);
				for (i = 0; i < referenceCount; i++) {
					var reference = {
						path: reader.string(),
						guid: reader.readAsHexNumber(16),
						type: reader.getU4(),
						filePath: reader.string()
					};
					console.log('[reference]\npath: ' + reference.path + '\nguid: ' + reference.guid + '\ntype: ' + reference.type + '\nfilePath: ' + reference.filePath);
					references.push(reference);
				}
			}
		};
		var processObjectValue = function (reader) {

		};
		var processTypeTree = function (reader) {
			var nodes = [];
			var nodeCount = reader.getU4();
			var bufferSize = reader.getU4();
			console.log('[tree] nodeCount: ' + nodeCount + '\nbufferSize: ' + bufferSize);
			var i;
			for (i = 0; i < nodeCount; i++) {
				var node = {
					version: reader.getU2(),
					depth: reader.getU1(),
					isArray: (reader.getU1() !== 0),
					type: reader.getU4(),
					name: reader.getU4(),
					size: reader.getU4(),
					index: reader.getU4(),
					flags: reader.getU4()
				};
				//alert('[node]\nversion: ' + node.version + '\ndepth: ' + node.depth + '\nisArray: ' + node.isArray + '\ntype: ' + node.type + '\nname: ' + node.name + '\nsize: ' + node.size + "\nindex: " + node.index + "\nflags: " + node.flags);
				nodes.push(node);
			}
			var bufferBegin = reader.getPosition();
			for (i = 0; i < nodeCount; i++) {
				var node = nodes[i];
				if ((node.type & 0x80000000) === 0) {
					reader.setPosition(bufferBegin + node.type)
					node.type = reader.getString();
				}
				if ((node.name & 0x80000000) === 0) {
					reader.setPosition(bufferBegin + node.name)
					node.name = reader.getString();
				}
				console.log('[node]\nversion: ' + node.version + '\ndepth: ' + node.depth + '\nisArray: ' + node.isArray + '\ntype: ' + node.type + '\nname: ' + node.name + '\nsize: ' + node.size + "\nindex: " + node.index + "\nflags: " + node.flags);
			}
			reader.setPosition(bufferBegin);
			reader.skip(bufferSize);
		};

	}());

</script>


</html>