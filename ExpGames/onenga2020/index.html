<!DOCTYPE html>
<html>

<head>
	<style type="text/css">
		<!--
		.center {
			text-align: center;
		}

		.floatLeft {
			text-align: left;
			float: left;
		}
		-->
	</style>
	<meta charset="utf-8">
	<title>カヤック年賀2020 </title>
</head>

<body>
	<div class="center">
		<canvas id="screen"></canvas>
	</div>

	<script id="3dvs" type="x-shader/x-vertex">
precision mediump float;

attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;

varying vec3 vNormal;
varying vec2 vTexCoord;

uniform vec4 transform0;
uniform vec4 transform1;
uniform vec4 transform2;
uniform vec4 transform3;
uniform vec3 toWorld0;
uniform vec3 toWorld1;
uniform vec3 toWorld2;

void main(){
	vec4 p = vec4(aPosition.xyz, 1.0);
	gl_Position.x = dot(transform0, p);
	gl_Position.y = dot(transform1, p);
	gl_Position.z = dot(transform2, p);
	gl_Position.w = dot(transform3, p);
	vTexCoord = aTexCoord;
	vNormal.x = dot(toWorld0, aNormal);
	vNormal.y = dot(toWorld1, aNormal);
	vNormal.z = dot(toWorld2, aNormal);
}
</script>

	<script id="3dfs" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D uSampler;
varying vec3 vNormal; // world
varying vec2 vTexCoord;

void main(){
	vec4 c = texture2D(uSampler, vTexCoord);
	vec3 lightVector = vec3(0.57, 0.57, -0.57); // 仮
//	vec3 lightVector = vec3(0.0, 1.0, 0.0); // 仮

	vec3 ambient = vec3(0.2, 0.2, 0.2); // 仮
	float dp = dot(vNormal, lightVector);
	c.xyz *= dp;
	c.xyz += ambient;
	gl_FragColor = c;
}
</script>

	<script id="2dvs" type="x-shader/x-vertex">
precision mediump float;
attribute vec2 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
uniform vec3 transform0;
uniform vec3 transform1;

void main(){
	vec3 p = vec3(aPosition.xy, 1.0);
	gl_Position.x = dot(transform0, p);
	gl_Position.y = dot(transform1, p);
	gl_Position.z = -1.0;
	gl_Position.w = 1.0;
	vTexCoord = aTexCoord;
}
</script>

	<script id="2dfs" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D uSampler;
varying vec2 vTexCoord;

void main(){
	gl_FragColor = texture2D(uSampler, vTexCoord);
}
</script>

	<script id="utilLib">
		"use strict";
		var Kayac = Kayac || {}; //名前空間オブジェクト

		Kayac.msbIndex = function (x) {
			var r = 0;
			if (x & 0xffff0000) {
				r += 16;
				x >>>= 16;
			}
			if (x & 0xff00) {
				r += 8;
				x >>>= 8;
			}
			if (x & 0xf0) {
				r += 4;
				x >>>= 4;
			}
			if (x & 0xc) {
				r += 2;
				x >>>= 2;
			}
			if (x & 0x2) {
				r += 1;
				x >>>= 1;
			}
			return (x === 1) ? r : -1;
		};

		Kayac.clamp = function (x, min, max) {
			x = (x < min) ? min : x;
			x = (x > max) ? max : x;
			return x;
		};

		Kayac.isPowerOf2 = function (x) {
			return (x & (x - 1)) === 0;
		};

		//角度→ラジアン
		Kayac.toRadian = function (x) {
			return x * (Math.PI / 180);
		};

		//整数乱数。最小値と種類数。6面サイコロなら1,6
		Kayac.randomInt = function (min, count) {
			var t = Math.random() * count; //[0, count)
			t = Math.floor(t); //[0, count-1]
			t += min; //[min, min+count-1]
			return t;
		};

		//配列オフセットつきコピー
		Kayac.copyArray = function (dst, dstOffset, src, srcOffset, count) {
			for (var i = 0; i < count; i += 1) {
				dst[dstOffset + i] = src[srcOffset + i];
			}
		};

		//配列埋め
		Kayac.fillArray = function (dst, dstOffset, value, count) {
			for (var i = 0; i < count; i += 1) {
				dst[dstOffset + i] = value;
			}
		};

		//ビット反転
		Kayac.reverseBit = function (x) {
			var a = x & 0xffff0000;
			var b = x & 0x0000ffff;
			x = (a >>> 16) | (b << 16); //右シフトは論理シフトね。
			a = x & 0xff00ff00;
			b = x & 0x00ff00ff;
			x = (a >>> 8) | (b << 8);
			a = x & 0xf0f0f0f0;
			b = x & 0x0f0f0f0f;
			x = (a >>> 4) | (b << 4);
			a = x & 0xcccccccc;
			b = x & 0x33333333;
			x = (a >>> 2) | (b << 2);
			a = x & 0xaaaaaaaa;
			b = x & 0x55555555;
			x = (a >>> 1) | (b << 1);
			return x;
		};

		//3要素の最小値を番号で返す(0,1,2)
		Kayac.min3Index = function (a, b, c) {
			var r;
			if (a < b) {
				if (a < c) {
					r = 0;
				} else {
					r = 2;
				}
			} else {
				if (b < c) {
					r = 1;
				} else {
					r = 2;
				}
			}
			return r;
		};

		Kayac.max3Index = function (a, b, c) {
			var r;
			if (a > b) {
				if (a > c) {
					r = 0;
				} else {
					r = 2;
				}
			} else {
				if (b > c) {
					r = 1;
				} else {
					r = 2;
				}
			}
			return r;
		};


		//画像ロード
		//srcはHTMLImageElement, Blob, urlが入ったstringのいずれか
		Kayac.startLoadImage = function (src, name, callback) {
			//ImgかBlobか判定
			var url;
			var img;
			var srcIsImg = false;
			var srcIsBlob = false;
			if ((typeof src.alt) !== 'undefined') { //Img
				img = sr;
				srcIsImg = true;
			} else if (
				((typeof src.size) !== 'undefined') &&
				((typeof src.type) !== 'undefined') &&
				((typeof src.slice) !== 'undefined')) { //Blob
				url = URL.createObjectURL(src);
				srcIsBlob = true;
			} else { //url
				url = src;
			}
			if (!srcIsImg) {
				img = document.createElement('img');
				img.style = 'display:none;';
				document.body.appendChild(img);
			}
			var onLoadEnd = function (e) {
				var canvas = document.createElement('canvas');
				canvas.style = 'display:none;';
				var w = img.width;
				var h = img.height;
				canvas.width = w;
				canvas.height = h;
				document.body.appendChild(canvas);
				var context = canvas.getContext('2d');
				context.drawImage(img, 0, 0);
				var imageData = context.getImageData(0, 0, w, h);
				var image = { width: w, height: h, name: name, data: null };
				image.data = new Uint8Array(w * h * 4);
				Kayac.degamma(image.data, imageData.data);
				var body = document.body;
				body.removeChild(canvas);
				if (!srcIsImg) {
					body.removeChild(img);
				}
				if (srcIsBlob) { //後始末
					URL.revokeObjectURL(url);
				}
				callback(image);
			};
			img.addEventListener('load', onLoadEnd, false);
			img.src = url;
		};

		//ガンマ変換 RGBAを仮定し、Aは触らない
		Kayac.degamma = function (dstArrayBuffer, srcArrayBuffer) {
			var n = srcArrayBuffer.length / 4;
			for (var i = 0; i < n; i += 1) {
				var r = srcArrayBuffer[(i * 4) + 0] / 255;
				var g = srcArrayBuffer[(i * 4) + 1] / 255;
				var b = srcArrayBuffer[(i * 4) + 2] / 255;
				var a = srcArrayBuffer[(i * 4) + 3];
				r = Math.pow(r, 2.2);
				g = Math.pow(g, 2.2);
				b = Math.pow(b, 2.2);
				dstArrayBuffer[(i * 4) + 0] = Math.floor((r * 255) + 0.5);
				dstArrayBuffer[(i * 4) + 1] = Math.floor((g * 255) + 0.5);
				dstArrayBuffer[(i * 4) + 2] = Math.floor((b * 255) + 0.5);
				dstArrayBuffer[(i * 4) + 3] = a;
			}
		};

		//e:HTMLElement。中のテキストを結合して返す
		Kayac.concatenateTextInElement = function (e) {
			var r = '';
			var c = e.firstChild;
			while (c) {
				if (c.nodeType === c.TEXT_NODE) {
					r += c.textContent;
				}
				c = c.nextSibling;
			}
			return r;
		};
	</script>

	<script id="glLib">
		"use strict";
		var Kayac = Kayac || {}; //名前空間オブジェクト

		//Gpuクラス: 要するにGLを楽に使うためのラッパー
		//コンストラクタ
		//arg.canvas: 描くキャンバスか、そのid
		Kayac.Gpu = function (arg) {
			//メンバ変数
			this.mGl = null; //WebGlRenderingContext
			this.mShader = null; //現在設定中のシェーダ
			this.mVertexBuffer = null; //現在設定中の頂点バッファ
			this.mVertexFormat = null; //現在設定中の頂点フォーマット
			this.mTextureMap = {}; //シェーダ内の名前とテクスチャオブジェクトの対応表
			this.mDefaultTexture = null; //テクスチャなしで描画された時に自動で使う1x1の白テクスチャ
			this.mFullScreenVertexBuffer = null; //全画面描画用頂点バッファ
			this.mFullScreenVertexBufferFlipV = null; //全画面描画用頂点バッファ(V逆)
			this.mFullScreenVertexFormat = null; //全画面描画用頂点フォーマット
			//以下処理
			var canvas = arg.canvas;
			if ((typeof canvas) === 'string') { //文字列なら引くよ
				canvas = document.getElementById(canvas);
			}
			var attributes = { antialias: true, depth: true };
			var gl = canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl'); //後ろはIE用
			this.mGl = gl;
			//デフォルトテクスチャ生成
			var texData = new Uint8Array(4);
			texData[0] = texData[1] = texData[2] = texData[3] = 255;
			var texArg = {
				gpu: this,
				width: 1,
				height: 1,
				data: texData,
				name: 'defaultTexture'
			};
			this.mDefaultTexture = new Kayac.Texture(texArg);
			//drawFullScreen用のデータ用意
			var vbData = new Float32Array(3 * 4); //3頂点4スカラ
			Kayac.copyArray(vbData, 0, [-1, 3, 0, -1], 0, 4); //左上
			Kayac.copyArray(vbData, 4, [-1, -1, 0, 1], 0, 4); //左下
			Kayac.copyArray(vbData, 8, [3, -1, 2, 1], 0, 4); //右下
			this.mFullScreenVertexBuffer = new Kayac.VertexBuffer({
				gpu: this,
				name: 'fullScreenVb',
				data: vbData
			});

			Kayac.copyArray(vbData, 0, [-1, 3, 0, 2], 0, 4); //左上
			Kayac.copyArray(vbData, 4, [-1, -1, 0, 0], 0, 4); //左下
			Kayac.copyArray(vbData, 8, [3, -1, 2, 0], 0, 4); //右下
			this.mFullScreenVertexBufferFlipV = new Kayac.VertexBuffer({
				gpu: this,
				name: 'fullScreenVbFlipV',
				data: vbData
			});

			this.mFullScreenVertexFormat = {
				stride: 16,
				elements: [
					{ offset: 0, vectorDimension: 2, name: 'aPosition' },
					{ offset: 8, vectorDimension: 2, name: 'aTexCoord' }]
			};

			//初期設定
			gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
			gl.clearColor(0, 0, 0, 1);
			gl.clearDepth(1);
			gl.clear(gl.COLOR_BUFFER_BIT);
			//			gl.cullFace(gl.FRONT); // TODO: 場合によっては必要になるかも。真面目に考えてない。

			//エラーチェック
			var e = gl.getError();
			if (e !== gl.NO_ERROR) {
				throw 'GL Error: ' + e;
			}
		};

		Kayac.Gpu.Primitive = {
			Triangle: 0,
			Point: 1,
			Line: 2
		};

		Kayac.Gpu.prototype.getGl = function () {
			return this.mGl;
		};

		Kayac.Gpu.prototype.renderingWidth = function () {
			return this.mGl.drawingBufferWidth;
		};

		Kayac.Gpu.prototype.renderingHeight = function () {
			return this.mGl.drawingBufferHeight;
		};

		//クリアする。指定する色は0から1
		//clear([0.2, 0.3, 0.4, 0.5]); アルファを省略すれば1
		//clear(0.2, 0.3, 0.4, 0.5); //アルファを省略すれば1
		//clear(); //透明な黒でクリア。アルファ0に注意！
		Kayac.Gpu.prototype.clear = function (rOrArray, g, b, a) {
			var cr = 0;
			var cg = 0;
			var cb = 0;
			var ca = 0;
			if ((typeof rOrArray) !== 'undefined') { //引数がある
				if (rOrArray.length) { //色が配列で来た
					var c = rOrArray;
					cr = c[0];
					cg = c[1];
					cb = c[2];
					if (c.length >= 4) {
						ca = c[3];
					} else {
						ca = 1;
					} //RGBだけ入れてアルファを入れない時もあるのでアルファのデフォルトは1とする。
				} else { //要素別
					ca = 1; //RGBだけ入れてアルファを入れない時もあるのでアルファのデフォルトは1とする。
					cr = rOrArray;
					if ((typeof g) !== 'undefined') {
						cg = g;
					}
					if ((typeof b) !== 'undefined') {
						cb = b;
					}
					if ((typeof a) !== 'undefined') {
						ca = a;
					}
				}
			}
			var gl = this.mGl;
			//webGLでは前乗算されている前提らしいので、乗じてやる。
			//TODO:最終的にトーンマッピング段でやる方がいい。塗り残しに2重にかかってしまう。
			cr *= ca;
			cg *= ca;
			cb *= ca;
			gl.clearColor(cr, cg, cb, ca);
			gl.clearDepth(1);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			//クリアなんて頻繁にやらないだろうから、このタイミングでエラーチェックとコマンドのフラッシュを行う
			gl.flush();
			var e = gl.getError();
			if (e !== gl.NO_ERROR) {
				throw 'GL Error: ' + e;
			}
		};

		Kayac.Gpu.prototype.setShader = function (shader) {
			if (this.mShader !== shader) {
				this.mShader = shader;
				//シェーダセット
				var program = this.mShader.getGlObject();
				this.mGl.useProgram(program);
			}
		};

		Kayac.Gpu.prototype.setTexture = function (name, texture) {
			if (!texture) {
				this.mTextureMap[name] = this.mDefaultTexture;
			} else {
				this.mTextureMap[name] = texture;
			}
		};

		Kayac.Gpu.prototype.setRenderTarget = function (renderTarget) {
			var gl = this.mGl;
			if (!renderTarget) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
			} else {
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getGlObject());
				var tex = renderTarget.colorBuffer;
				gl.viewport(
					0,
					0,
					tex.width,
					tex.height);
			}
		};
		Kayac.Gpu.prototype.setBlendEnabled = function (enabled) {
			var gl = this.mGl;
			if (enabled === true) {
				//				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			} else if (enabled === false) {
				gl.disable(gl.BLEND);
			} else {
				throw 'Gpu.setBlendEnabled invalid arg: ' + enabled;
			}
		};
		Kayac.Gpu.prototype.setDepthTest = function (test, write) {
			var gl = this.mGl;
			if (test === true) {
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				if (write === true) {
					gl.depthMask(true);
				} else if (write === false) {
					gl.depthMask(false);
				} else {
					throw 'Gpu.setDepthTest invalid arg: write=' + write;
				}
			} else if (test === false) {
				if (write === true) {
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.ALWAYS);
				} else if (write === false) {
					gl.disable(gl.DEPTH_TEST);
				} else {
					throw 'Gpu.setDepthTest invalid arg: write=' + write;
				}
			} else {
				throw 'Gpu.setDepthWriteEnabled invalid arg: test=' + test;
			}
		};
		Kayac.Gpu.prototype.setFaceCullingEnabled = function (enabled) {
			var gl = this.mGl;
			if (enabled === true) {
				gl.enable(gl.CULL_FACE);
			} else if (enabled === false) {
				gl.disable(gl.CULL_FACE);
			} else {
				throw 'Gpu.setBlendEnabled invalid arg: ' + enabled;
			}
		}

		//VertexFormatの構造は例えばこんな感じ
		//var fmt = {
		//   stride:16
		//   elements:[
		//      {name:'aPosition', offset:0, vectorDimension:2},
		//      {name:'aTexCoord', offset:8, vectorDimension:2}};
		Kayac.Gpu.prototype.setVertexFormat = function (format) {
			this.mVertexFormat = format;
		};

		Kayac.Gpu.prototype.setVertexBuffer = function (vb) {
			this.mVertexBuffer = vb;
		};

		Kayac.Gpu.prototype.draw = function (vertexCount, primitiveType, startVertexIndex) {
			if (!(this.mShader)) {
				throw 'Gpu.draw(): call setShader().';
			}
			if (!(this.mVertexFormat)) {
				throw 'Gpu.draw(): call setVertexFormat().';
			}
			if (!(this.mVertexBuffer)) {
				throw 'Gpu.draw(): call setVertexBuffer().';
			}
			var gl = this.mGl;
			var program = this.mShader.getGlObject();

			//テクスチャセット
			var unitNames = [
				gl.TEXTURE0,
				gl.TEXTURE1,
				gl.TEXTURE2,
				gl.TEXTURE3,
				gl.TEXTURE4,
				gl.TEXTURE5,
				gl.TEXTURE6,
				gl.TEXTURE7];
			var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
			var i = 0;
			var unitIndex = 0;
			var defaultTex = this.mDefaultTexture.getGlObject();
			//全部一旦デフォルトセット
			while ((i < uniformCount) && (unitIndex < 8)) {
				var u = gl.getActiveUniform(program, i);
				if (u.type === gl.SAMPLER_2D) {
					gl.activeTexture(unitNames[unitIndex]);
					gl.bindTexture(gl.TEXTURE_2D, defaultTex);
					unitIndex += 1;
				}
				i += 1;
			}
			//ユーザが差したものセット
			unitIndex = 0;
			for (var name in this.mTextureMap) {
				if (this.mTextureMap.hasOwnProperty(name)) {
					var tex = this.mTextureMap[name];
					gl.activeTexture(unitNames[unitIndex]);
					gl.bindTexture(gl.TEXTURE_2D, tex.getGlObject());
					var loc = gl.getUniformLocation(program, name);
					if (loc !== null) {
						gl.uniform1i(loc, unitIndex);
						unitIndex += 1;
						if (unitIndex >= 8) {
							break;
						}
					}
				}
			}
			//頂点バッファ
			gl.bindBuffer(gl.ARRAY_BUFFER, this.mVertexBuffer.getGlObject());
			//頂点フォーマット
			//一旦全部無効化。TODO:必要なのこれ？
			var attribCount = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
			for (i = 0; i < attribCount; i += 1) {
				gl.disableVertexAttribArray(i);
			}
			attribCount = this.mVertexFormat.elements.length;
			var stride = this.mVertexFormat.stride;
			for (i = 0; i < attribCount; i += 1) {
				var e = this.mVertexFormat.elements[i];
				var loc = gl.getAttribLocation(program, e.name);
				if (loc >= 0) {
					gl.enableVertexAttribArray(loc);
					gl.vertexAttribPointer(loc, e.vectorDimension, gl.FLOAT, 0, stride, e.offset);
				}
			}
			//描画キック
			primitiveType = primitiveType || Kayac.Gpu.Primitive.Triangle; //undefinedなら0
			var prims = [
				gl.TRIANGLES,
				gl.POINTS,
				gl.LINES];
			var start = startVertexIndex || 0;
			gl.drawArrays(prims[primitiveType], start, vertexCount);
		};

		Kayac.Gpu.prototype.drawFullScreen = function (readsRenderTexture) {
			//今刺さってるものを覚えておいて後で復帰
			var vbBack = this.mVertexBuffer;
			var vfBack = this.mVertexFormat;
			if (readsRenderTexture) {
				this.setVertexBuffer(this.mFullScreenVertexBufferFlipV);
			} else {
				this.setVertexBuffer(this.mFullScreenVertexBuffer);
			}
			this.setVertexFormat(this.mFullScreenVertexFormat);
			this.draw(3);
			this.setVertexBuffer(vbBack);
			this.setVertexFormat(vfBack);
		};

		Kayac.Gpu.prototype.setConstant = function (name, value) {
			if (!this.mShader) {
				throw 'Gpu.setConstant: call setShader().';
			}
			var gl = this.mGl;
			var l = gl.getUniformLocation(this.mShader.getGlObject(), name);
			if (l) {
				if (value.length) {
					var c = value.length;
					if (c >= 3) { //3以上
						if (c >= 4) { //4
							gl.uniform4f(l, value[0], value[1], value[2], value[3]);
						} else { //3
							gl.uniform3f(l, value[0], value[1], value[2]);
						}
					} else {
						if (c == 2) { //2
							gl.uniform2fv(l, value[0], value[1]);
						} else { //1
							gl.uniform1fv(l, value[0]);
						}
					}
				} else {
					gl.uniform1f(l, value);
				}
			}
		};

		//RenderTarget
		Kayac.RenderTarget = function (arg) {
			//メンバ変数
			this.name = arg.name || '';
			this.colorBuffer = arg.colorBuffer;

			this.mGlObject = null;
			this.mGl = arg.gpu.getGl();
			//以下処理
			var gl = this.mGl; //たくさん使うので短く
			if (!gl) { //gpu先に初期化しろよ
				throw 'Kayac.Texture() : Gpuクラスを渡してね！';
			}
			this.mGlObject = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.mGlObject);
			var tex = this.colorBuffer.getGlObject();
			gl.framebufferTexture2D(
				gl.FRAMEBUFFER,
				gl.COLOR_ATTACHMENT0,
				gl.TEXTURE_2D,
				tex,
				0);
			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (status !== gl.FRAMEBUFFER_COMPLETE) {
				throw 'Kayac.RenderTarget() : framebuffer incomplete.';
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		};

		Kayac.RenderTarget.prototype.getGlObject = function () {
			return this.mGlObject;
		};

		//Textureクラス
		//コンストラクタ
		Kayac.Texture = function (arg) {
			//メンバ変数
			this.name = arg.name || ''; //名前。主にデバグ用。
			if ((Kayac.isPowerOf2(arg.width) === false) || (Kayac.isPowerOf2(arg.height) === false)) {
				throw 'Kayac.Texture() : サイズは2の累乗にしてね！'
			}
			this.width = arg.width;
			this.height = arg.height;

			this.mGlObject = null; //GLハンドル
			this.mGl = arg.gpu.getGl();
			//以下処理
			var gl = this.mGl; //たくさん使うので短く
			if (!gl) { //gpu先に初期化しろよ
				throw 'Kayac.Texture() : Gpuクラスを渡してね！';
			}
			var img = arg.img; //画像指定あればそこから作るよ
			if ((typeof img) === 'string') {  //文字列ならidとみなして引く
				img = document.getElementById(img);
			}
			this.mGlObject = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, this.mGlObject);
			if (img) {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
			} else if (arg.data) {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, arg.width, arg.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, arg.data);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, arg.width, arg.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}
			var minFilter;
			var magFilter;
			if (arg.mipmap === true) {
				gl.generateMipmap(gl.TEXTURE_2D);
				if (arg.pointSampling === true) {
					minFilter = gl.NEAREST_MIPMAP_NEAREST;
					magFilter = gl.NEAREST;
				} else {
					magFilter = minFilter = gl.NEAREST;

				}
			} else {
				if (arg.pointSampling === true) {
					magFilter = minFilter = gl.NEAREST;
				} else {
					magFilter = minFilter = gl.LINEAR;
				}
			}
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

			//エラーチェック
			var e = gl.getError();
			if (e !== gl.NO_ERROR) {
				throw 'GL Error: ' + e;
				return null;
			}
		};

		Kayac.Texture.prototype.update = function (data) {
			var gl = this.mGl; //たくさん使うので短く
			gl.bindTexture(gl.TEXTURE_2D, this.mGlObject);
			gl.texSubImage2D(
				gl.TEXTURE_2D,  //target
				0, //level
				0, //xoffset
				0, //yoffset
				this.width,
				this.height,
				gl.RGBA, //format
				gl.UNSIGNED_BYTE, //type
				data); //pixels
		};

		Kayac.Texture.prototype.getGlObject = function () {
			return this.mGlObject;
		};

		//VertexBufferクラス
		Kayac.VertexBuffer = function (arg) {
			//メンバ変数
			this.mGlObject = null;
			this.mName = arg.name || ''; //名前。主にデバグ用。
			this.mSize = 0; //バイト数
			this.mGl = arg.gpu.getGl();

			//処理本体
			var gl = this.mGl; //たくさん使うので短く
			if (!gl) { //gpu先に初期化しろよ
				throw 'Kayac.VertexBuffer() Gpuクラスを渡してね！';
			}
			this.mGlObject = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.mGlObject);
			if (arg.data) {
				if (arg.size) {
					throw 'Kayac.VertexBuffer() : 引数不正。dataとsizeはどちらかにして。';
				}
				gl.bufferData(gl.ARRAY_BUFFER, arg.data, gl.STATIC_DRAW);
				if (arg.data.byteLength) { //TypedArray
					this.mSize = arg.data.byteLength;
				} else { //ArrayBuffer
					this.mSize = arg.data.length;
				}
			} else if (arg.size) { //空で作ったらDynamic扱い
				gl.bufferData(gl.ARRAY_BUFFER, arg.size, gl.DYNAMIC_DRAW);
				this.mSize = arg.size;
			} else {
				throw 'VertexBuffer() : invalid arg. data or size is mandatory.';
			}
			//エラーチェック
			var e = gl.getError();
			if (e !== gl.NO_ERROR) {
				throw 'GL Error: ' + e;
			}
		};

		Kayac.VertexBuffer.prototype.update = function (data) {
			var gl = this.mGl;
			gl.bindBuffer(gl.ARRAY_BUFFER, this.mGlObject);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
		};

		Kayac.VertexBuffer.prototype.getGlObject = function () {
			return this.mGlObject;
		};

		//Shaderクラス。programを保持。頂点とフラグメントをセットにして生成する。
		Kayac.Shader = function (arg) {
			//メンバ変数
			this.mGlObject = null; //program
			this.mGl = arg.gpu.getGl();
			this.mName = arg.name || 'unnamed shader';
			//処理本体
			var gl = this.mGl;
			var vsElement = document.getElementById(arg.vertexShaderId);
			var fsElement = document.getElementById(arg.fragmentShaderId);
			var vsSrc = Kayac.concatenateTextInElement(vsElement);
			var fsSrc = Kayac.concatenateTextInElement(fsElement);
			var vs = gl.createShader(gl.VERTEX_SHADER);
			var fs = gl.createShader(gl.FRAGMENT_SHADER);
			var msg;
			gl.shaderSource(vs, vsSrc);
			gl.compileShader(vs);
			msg = gl.getShaderInfoLog(vs);
			if (msg.length > 0) {
				throw msg;
			}
			gl.shaderSource(fs, fsSrc);
			gl.compileShader(fs);
			msg = gl.getShaderInfoLog(fs);
			if (msg.length > 0) {
				throw msg;
			}
			this.mGlObject = gl.createProgram();
			gl.attachShader(this.mGlObject, vs);
			gl.attachShader(this.mGlObject, fs);
			gl.linkProgram(this.mGlObject);
			gl.validateProgram(this.mGlObject);
			msg = gl.getProgramInfoLog(this.mGlObject); if (msg.length > 0) {
				throw msg;
			}
		};

		Kayac.Shader.prototype.getGlObject = function () {
			return this.mGlObject;
		};
	</script>

	<script id="mathLib">
		var Kayac = Kayac || {};

		//2要素配列ベクタ演算
		Kayac.add2 = function (self, a) {
			self[0] += a[0];
			self[1] += a[1];
		};

		Kayac.setAdd2 = function (self, a, b) {
			self[0] = a[0] + b[0];
			self[1] = a[1] + b[1];
		};

		Kayac.sub2 = function (self, a) {
			self[0] -= a[0];
			self[1] -= a[1];
		};

		Kayac.setSub2 = function (self, a, b) {
			self[0] = a[0] - b[0];
			self[1] = a[1] - b[1];
		};

		Kayac.mul2 = function (self, a) {
			self[0] *= a[0];
			self[1] *= a[1];
		};

		Kayac.setMul2 = function (self, a, b) {
			self[0] = a[0] * b[0];
			self[1] = a[1] * b[1];
		};

		Kayac.mulS2 = function (self, s) {
			self[0] *= s;
			self[1] *= s;
		};

		Kayac.setMulS2 = function (self, a, s) {
			self[0] = a[0] * s;
			self[1] = a[1] * s;
		};

		Kayac.setMadd2 = function (self, a, b, c) {
			self[0] = (a.x * b.x) + c.x;
			self[1] = (a.y * b.y) + c.y;
		};

		Kayac.setMaddS2 = function (self, a, s, b) {
			self[0] = (a.x * s) + b.x;
			self[1] = (a.y * s) + b.y;
		};

		//V2
		Kayac.V2 = function () {
		};

		Kayac.V2.setA = function (self, a) {
			self.x = a[0];
			self.y = a[1];
		};

		Kayac.V2.setXy = function (self, x, y) {
			self.x = x;
			self.y = y;
		};

		Kayac.V2.setV = function (self, v) {
			self.x = v.x;
			self.y = v.y;
		};

		Kayac.V2.createA = function (a) {
			var ret = new Kayac.V2();
			ret.setA(a);
			return ret;
		};

		Kayac.V2.createXy = function (x, y) {
			var ret = new Kayac.V2();
			ret.setXy(x, y);
			return ret;
		};

		Kayac.V2.createV = function (v) {
			var ret = new Kayac.V2();
			ret.setV(v);
			return ret;
		};

		Kayac.V2.add = function (self, a) {
			self.x += a.x;
			self.y += a.y;
		};

		Kayac.V2.setAdd = function (self, a, b) {
			self.x = a.x + b.x;
			self.y = a.y + b.y;
		};

		Kayac.V2.sub = function (self, a) {
			self.x -= a.x;
			self.y -= a.y;
		};

		Kayac.V2.setSub = function (self, a, b) {
			self.x = a.x - b.x;
			self.y = a.y - b.y;
		};

		Kayac.V2.mul = function (self, a) {
			self.x *= a.x;
			self.y *= a.y;
		};

		Kayac.V2.setMul = function (self, a, b) {
			self.x = a.x * b.x;
			self.y = a.y * b.y;
		};

		Kayac.V2.mulS = function (self, s) {
			self.x *= s;
			self.y *= s;
		};

		Kayac.V2.setMulS = function (self, a, s) {
			self.x = a.x * s;
			self.y = a.y * s;
		};

		Kayac.V2.setMadd = function (self, a, b, c) {
			self.x = (a.x * b.x) + c.x;
			self.y = (a.y * b.y) + c.y;
		};

		Kayac.V2.setMaddS = function (self, a, s, c) {
			self.x = (a.x * s) + b.x;
			self.y = (a.y * s) + c.y;
		};

		Kayac.V2.neg = function (self) {
			self.x = -self.x;
			self.y = -self.y;
		};

		Kayac.V2.setNeg = function (self, a) {
			self.x = -a.x;
			self.y = -a.y;
		};

		Kayac.V2.dot = function (a, b) {
			return (a.x * b.x) + (a.y * b.y);
		};

		Kayac.V2.sqMagnitude = function (self) {
			return (self.x * self.x) + (self.y * self.y);
		};

		Kayac.V2.magnitude = function (self) {
			return Math.sqrt(Kayac.V2.sqMagnitude(self));
		};

		Kayac.V2.normalize = function (self) {
			var V = Kayac.V2;
			var l = V.magnitude(self);
			if (l !== 0) {
				V.mul(self, 1 / l);
			}
		};

		Kayac.V2.setNormalized = function (self, a) {
			var V = Kayac.V2;
			var l = V.magnitude(a);
			if (l !== 0) {
				V.initToMul(self, a, 1 / l);
			}
		};

		Kayac.V2.setMin = function (self, a, b) {
			self.x = Math.min(a.x, b.x);
			self.y = Math.min(a.y, b.y);
		};

		Kayac.V2.min = function (self, a) {
			self.x = Math.min(self.x, a.x);
			self.y = Math.min(self.y, a.y);
		};

		Kayac.V2.setMax = function (self, a, b) {
			self.x = Math.max(a.x, b.x);
			self.y = Math.max(a.y, b.y);
		};

		Kayac.V2.max = function (self, a) {
			self.x = Math.max(self.x, a.x);
			self.y = Math.max(self.y, a.y);
		};

		//以下メソッド版。インライン展開してくれるかなあ
		Kayac.V2.prototype.setXyz = function (x, y) {
			Kayac.V2.setXy(this, x, y);
		};

		Kayac.V2.prototype.setV = function (v) {
			Kayac.V2.setV(this, v);
		};

		Kayac.V2.prototype.setA = function (a) {
			Kayac.V2.setA(this, a);
		};

		Kayac.V2.prototype.add = function (a) {
			Kayac.V2.add(this, a);
		};

		Kayac.V2.prototype.setAdd = function (a, b) {
			Kayac.V2.setAdd(this, a, b);
		};

		Kayac.V2.prototype.sub = function (a) {
			Kayac.V2.sub(this, a);
		};

		Kayac.V2.prototype.SetSub = function (a, b) {
			Kayac.V2.setSub(this, a, b);
		};

		Kayac.V2.prototype.mul = function (a) {
			Kayac.V2.mul(this, a);
		};

		Kayac.V2.prototype.setMul = function (a, b) {
			Kayac.V2.SetMul(this, a, b);
		};

		Kayac.V2.prototype.mulS = function (s) {
			Kayac.V2.mulS(this, s);
		};

		Kayac.V2.prototype.setMulS = function (a, s) {
			Kayac.V2.SetMulS(this, a, s);
		};

		Kayac.V2.prototype.setMadd = function (a, b, c) {
			Kayac.V2.SetMadd(this, a, b, c);
		};

		Kayac.V2.prototype.setMaddS = function (a, s, b) {
			Kayac.V2.SetMadd(this, a, s, b);
		};

		Kayac.V2.prototype.neg = function () {
			Kayac.V2.neg(this);
		}

		Kayac.V2.prototype.setNeg = function (a) {
			Kayac.V2.setNeg(this, a);
		}

		Kayac.V2.prototype.dot = function (a) {
			return Kayac.V2.dot(this, a);
		};

		Kayac.V2.prototype.sqMagnitude = function () {
			return Kayac.V2.sqMagnitude(this);
		};

		Kayac.V2.prototype.magnitude = function () {
			return Kayac.V2.magnitude(this);
		};

		Kayac.V2.prototype.normalize = function () {
			Kayac.V2.normalize(this);
		};

		Kayac.V2.prototype.setNormalized = function (a) {
			Kayac.V2.setNormalized(this, a);
		};

		Kayac.V2.prototype.setMin = function (a, b) {
			Kayac.V2.setMin(this, a, b);
		};

		Kayac.V2.prototype.min = function (a) {
			Kayac.V2.min(this, a);
		};

		Kayac.V2.prototype.setMax = function (a, b) {
			Kayac.V2.setMax(this, a, b);
		};

		Kayac.V2.prototype.max = function (a) {
			Kayac.V2.max(this, a);
		};

		//3要素配列ベクタ演算
		Kayac.add3 = function (self, a) {
			self[0] += a[0];
			self[1] += a[1];
			self[2] += a[2];
		};

		Kayac.setAdd3 = function (self, a, b) {
			self[0] = a[0] + b[0];
			self[1] = a[1] + b[1];
			self[2] = a[2] + b[2];
		};

		Kayac.sub3 = function (self, a) {
			self[0] -= a[0];
			self[1] -= a[1];
			self[2] -= a[2];
		};

		Kayac.setSub3 = function (self, a, b) {
			self[0] = a[0] - b[0];
			self[1] = a[1] - b[1];
			self[2] = a[2] - b[2];
		};

		Kayac.mul3 = function (self, a) {
			self[0] *= a[0];
			self[1] *= a[1];
			self[2] *= a[2];
		};

		Kayac.setMul3 = function (self, a, b) {
			self[0] = a[0] * b[0];
			self[1] = a[1] * b[1];
			self[2] = a[2] * b[2];
		};

		Kayac.mulS3 = function (self, s) {
			self[0] *= s;
			self[1] *= s;
			self[2] *= s;
		};

		Kayac.setMulS3 = function (self, a, s) {
			self[0] = a[0] * s;
			self[1] = a[1] * s;
			self[2] = a[2] * s;
		};

		Kayac.setMadd3 = function (self, a, b, c) {
			self[0] = (a[0] * b[0]) + c[0];
			self[1] = (a[1] * b[1]) + c[1];
			self[2] = (a[2] * b[2]) + c[2];
		};

		Kayac.setMaddS3 = function (self, a, s, b) {
			self[0] = (a[0] * s) + b[0];
			self[1] = (a[1] * s) + b[1];
			self[2] = (a[2] * s) + b[2];
		};

		//V3
		Kayac.V3 = function () {
		};

		Kayac.V3.setXyz = function (self, x, y, z) {
			self.x = x;
			self.y = y;
			self.z = z;
		};

		Kayac.V3.setV = function (self, v) {
			self.x = v.x;
			self.y = v.y;
			self.z = v.z;
		};

		Kayac.V3.setA = function (self, a) {
			self.x = a[0];
			self.y = a[1];
			self.z = a[2];
		};

		Kayac.V3.createA = function (a) {
			var ret = new Kayac.V3();
			ret.setA(a);
			return ret;
		};

		Kayac.V3.createXyz = function (x, y, z) {
			var ret = new Kayac.V3();
			ret.setXyz(x, y, z);
			return ret;
		};

		Kayac.V3.createV = function (v) {
			var ret = new Kayac.V3();
			ret.setV(v);
			return ret;
		};

		Kayac.V3.neg = function (self) {
			self.x = -self.x;
			self.y = -self.y;
			self.z = -self.z;
		};

		Kayac.V3.setNeg = function (self, a) {
			self.x = -a.x;
			self.y = -a.y;
			self.z = -a.z;
		};

		Kayac.V3.add = function (self, a) {
			self.x += a.x;
			self.y += a.y;
			self.z += a.z;
		};

		Kayac.V3.setAdd = function (self, a, b) {
			self.x = a.x + b.x;
			self.y = a.y + b.y;
			self.z = a.z + b.z;
		};

		Kayac.V3.sub = function (self, a) {
			self.x -= a.x;
			self.y -= a.y;
			self.z -= a.z;
		};

		Kayac.V3.setSub = function (self, a, b) {
			self.x = a.x - b.x;
			self.y = a.y - b.y;
			self.z = a.z - b.z;
		};

		Kayac.V3.mul = function (self, a) {
			self.x *= a.x;
			self.y *= a.y;
			self.z *= a.z;
		};

		Kayac.V3.setMul = function (self, a, b) {
			self.x = a.x * b.x;
			self.y = a.y * b.y;
			self.z = a.z * b.z;
		};

		Kayac.V3.mulS = function (self, s) {
			self.x *= s;
			self.y *= s;
			self.z *= s;
		};

		Kayac.V3.setMulS = function (self, a, s) {
			self.x = a.x * s;
			self.y = a.y * s;
			self.z = a.z * s;
		};

		Kayac.V3.setMadd = function (self, a, b, c) {
			self.x = (a.x * b.x) + c.x;
			self.y = (a.y * b.y) + c.y;
			self.z = (a.z * b.z) + c.z;
		};

		Kayac.V3.setMaddS = function (self, a, s, b) {
			self.x = (a.x * s) + b.x;
			self.y = (a.y * s) + b.y;
			self.z = (a.z * s) + b.z;
		};

		Kayac.V3.setMulQ = function (self, a, b) { //a,b共にクォタニオン
			self.x = (a.w * b.x) + (a.x * b.w) + (a.y * b.z) - (a.z * b.y);
			self.y = (a.w * b.y) + (a.y * b.w) + (a.z * b.x) - (a.x * b.z);
			self.z = (a.w * b.z) + (a.z * b.w) + (a.x * b.y) - (a.y * b.x);
		};

		Kayac.V3.setMulQCq = function (self, a, b) { //a,b共にクォタニオンだが、bは複素共軛
			self.x = -(a.w * b.x) + (a.x * b.w) - (a.y * b.z) + (a.z * b.y);
			self.y = -(a.w * b.y) + (a.y * b.w) - (a.z * b.x) + (a.x * b.z);
			self.z = -(a.w * b.z) + (a.z * b.w) - (a.x * b.y) + (a.y * b.x);
		};

		Kayac.V3.setMulCqQ = function (self, a, b) { //a,b共にクォタニオンだが、aは複素共軛
			self.x = (a.w * b.x) - (a.x * b.w) - (a.y * b.z) + (a.z * b.y);
			self.y = (a.w * b.y) - (a.y * b.w) - (a.z * b.x) + (a.x * b.z);
			self.z = (a.w * b.z) - (a.z * b.w) - (a.x * b.y) + (a.y * b.x);
		};

		Kayac.V3.dot = function (a, b) {
			return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
		};

		Kayac.V3.cross = function (self, a) {
			var x = (self.y * a.z) - (self.z * a.y);
			var y = (self.z * a.x) - (self.x * a.z);
			self.z = (self.x * a.y) - (self.y * a.x);
			self.x = x;
			self.y = y;
		};

		Kayac.V3.setCross = function (self, a, b) {
			//自分が引数に入っている可能性を考えてxyは一旦テンポラリに格納
			var x = (a.y * b.z) - (a.z * b.y);
			var y = (a.z * b.x) - (a.x * b.z);
			self.z = (a.x * b.y) - (a.y * b.x);
			self.x = x;
			self.y = y;
		};

		Kayac.V3.sqMagnitude = function (self) {
			return (self.x * self.x) + (self.y * self.y) + (self.z * self.z);
		};

		Kayac.V3.magnitude = function (self) {
			return Math.sqrt(Kayac.V3.sqMagnitude(self));
		};

		Kayac.V3.normalize = function (self) {
			var V = Kayac.V3;
			var l = V.magnitude(self);
			if (l !== 0) {
				V.mul(self, 1 / l);
			}
		};

		Kayac.V3.setNormalized = function (self, a) {
			var V = Kayac.V3;
			var l = V.magnitude(a);
			if (l !== 0) {
				V.initToMul(self, a, 1 / l);
			}
		};

		Kayac.V3.rotate = function (self, q) {
			var qv = new Kayac.Q(q);
			Kayac.Q.mulV(qv, self);
			Kayac.V3.setMulQCq(self, qv, q);
		};

		Kayac.V3.rotateRev = function (self, q) {
			var cqv = new Kayac.Q(q);
			cqv.x = -cqv.x;
			cqv.y = -cqv.y;
			cqv.z = -cqv.z;
			Kayac.Q.mulV(cqv, self);
			Kayac.V3.setMulQ(self, cqv, q);
		};

		Kayac.V3.setRotated = function (self, q, v) {
			var qv = new Kayac.Q(q);
			Kayac.Q.mulV(qv, v);
			Kayac.V3.setMulQCq(self, qv, q);
		};

		Kayac.V3.setRotatedRev = function (self, q, v) {
			var cqv = new Kayac.Q(q);
			cqv.x = -cqv.x;
			cqv.y = -cqv.y;
			cqv.z = -cqv.z;
			Kayac.Q.mulV(cqv, v);
			Kayac.V3.setMulQ(self, cqv, q);
		};

		/*
		v' = v - 2*dot(v,n)/dot(n,n)
		だが、高速化のために法線が正規化されていることを要求する
		結果はvと同じ長さ(正規化状態なら正規化を保証する)
		*/
		Kayac.V3.reflect = function (self, normalizedNormal) {
			var V = Kayac.V3;
			var vn = V.dot(self, normalizedNormal);
			V.setMaddS(self, normalizedNormal, -2 * vn, self);
		};

		Kayac.V3.initToReflected = function (self, v, normalizedNormal) {
			var V = Kayac.V3;
			var vn = V.dot(v, normalizedNormal);
			V.setMaddS(self, v, normalizedNormal, -2 * vn, self);
		};

		Kayac.V3.setMin = function (self, a, b) {
			self.x = Math.min(a.x, b.x);
			self.y = Math.min(a.y, b.y);
			self.z = Math.min(a.z, b.z);
		};

		Kayac.V3.min = function (self, a) {
			self.x = Math.min(self.x, a.x);
			self.y = Math.min(self.y, a.y);
			self.z = Math.min(self.z, a.z);
		};

		Kayac.V3.setMax = function (self, a, b) {
			self.x = Math.max(a.x, b.x);
			self.y = Math.max(a.y, b.y);
			self.z = Math.max(a.z, b.z);
		};

		Kayac.V3.max = function (self, a) {
			self.x = Math.max(self.x, a.x);
			self.y = Math.max(self.y, a.y);
			self.z = Math.max(self.z, a.z);
		};

		//以下メソッド版。インライン展開してくれるかなあ
		Kayac.V3.prototype.setXyz = function (x, y, z) {
			Kayac.V3.setXyz(this, x, y, z);
		};

		Kayac.V3.prototype.setV = function (v) {
			Kayac.V3.setV(this, v);
		};

		Kayac.V3.prototype.setA = function (a) {
			Kayac.V3.setA(this, a);
		};

		Kayac.V3.prototype.add = function (a) {
			Kayac.V3.add(this, a);
		};

		Kayac.V3.prototype.setAdd = function (a, b) {
			Kayac.V3.setAdd(this, a, b);
		};

		Kayac.V3.prototype.sub = function (a) {
			Kayac.V3.sub(this, a);
		};

		Kayac.V3.prototype.SetSub = function (a, b) {
			Kayac.V3.setSub(this, a, b);
		};

		Kayac.V3.prototype.mul = function (a) {
			Kayac.V3.mul(this, a);
		};

		Kayac.V3.prototype.setMul = function (a, b) {
			Kayac.V3.setMul(this, a, b);
		};

		Kayac.V3.prototype.mulS = function (s) {
			Kayac.V3.mulS(this, s);
		};

		Kayac.V3.prototype.setMulS = function (a, s) {
			Kayac.V3.setMulS(this, a, s);
		};

		Kayac.V3.prototype.neg = function () {
			Kayac.V3.neg(this);
		};

		Kayac.V3.prototype.setNeg = function (a) {
			Kayac.V3.setNeg(this, a);
		};

		Kayac.V3.prototype.setMadd = function (a, b, c) {
			Kayac.V3.setMadd(this, a, b, c);
		};

		Kayac.V3.prototype.setMaddS = function (a, s, b) {
			Kayac.V3.setMaddS(this, a, s, b);
		};

		Kayac.V3.prototype.setMulQ = function (a, b) { //a,b共にクォタニオン
			Kayac.V3.setMulQ(this, a, b);
		};

		Kayac.V3.prototype.setMulQCq = function (a, b) { //a,b共にクォタニオンだが、bは複素共軛化
			Kayac.V3.setMulQCq(this, a, b);
		};

		Kayac.V3.prototype.setMulCqQ = function (a, b) { //a,b共にクォタニオンだが、aは複素共軛化
			Kayac.V3.setMulCqQ(this, a, b);
		};

		Kayac.V3.prototype.dot = function (a) {
			return Kayac.V3.dot(this, a);
		};

		Kayac.V3.prototype.cross = function (a) {
			Kayac.V3.cross(this, a);
		};

		Kayac.V3.prototype.setCross = function (a, b) {
			Kayac.V3.setCross(this, a, b);
		};

		Kayac.V3.prototype.sqMagnitude = function () {
			return Kayac.V3.sqMagnitude(this);
		};

		Kayac.V3.prototype.magnitude = function () {
			return Kayac.V3.magnitude(this);
		};

		Kayac.V3.prototype.normalize = function () {
			Kayac.V3.normalize(this);
		};

		Kayac.V3.prototype.setNormalized = function (a) {
			Kayac.V3.setNormalized(this, a);
		};

		Kayac.V3.prototype.rotate = function (q) {
			Kayac.V3.rotate(this, q);
		};

		Kayac.V3.prototype.rotateRev = function (q) {
			Kayac.V3.rotateRev(this, q);
		};

		Kayac.V3.prototype.setRotated = function (q, v) {
			Kayac.V3.setRotated(this, q, v);
		};

		Kayac.V3.prototype.setRotatedRev = function (q, v) {
			Kayac.V3.setRotatedRev(this, q, v);
		};

		Kayac.V3.prototype.reflect = function (normalizedNormal) {
			Kayac.V3.reflect(this, normalizedNormal);
		};

		Kayac.V3.prototype.setReflected = function (v, normalizedNormal) {
			Kayac.V3.setReflected(this, v, normalizedNormal);
		};

		Kayac.V3.prototype.setMin = function (a, b) {
			Kayac.V3.setMin(this, a, b);
		};

		Kayac.V3.prototype.min = function (a) {
			Kayac.V3.min(this, a);
		};

		Kayac.V3.prototype.setMax = function (a, b) {
			Kayac.V3.setMax(this, a, b);
		};

		Kayac.V3.prototype.max = function (a) {
			Kayac.V3.max(this, a);
		};

		//Q
		Kayac.Q = function () {
		};

		Kayac.Q.setXyzw = function (self, x, y, z, w) {
			self.x = x;
			self.y = y;
			self.z = z;
			self.w = w;
		};

		Kayac.Q.setA = function (self, a) {
			self.x = a[0];
			self.y = a[1];
			self.z = a[2];
			self.w = a[3];
		};

		Kayac.Q.setQ = function (self, q) {
			self.x = q.x;
			self.y = q.y;
			self.z = q.z;
			self.w = q.w;
		};

		Kayac.Q.createXyzw = function (x, y, z, w) {
			var ret = new Kayac.Q();
			ret.setXyzw(x, y, z, w);
			return ret;
		};

		Kayac.Q.createA = function (a) {
			var ret = new Kayac.Q();
			ret.setA(a);
			return ret;
		};

		Kayac.Q.createQ = function (q) {
			var ret = new Kayac.Q();
			ret.setQ(q);
			return ret;
		};

		Kayac.Q.setIdentity = function (self) {
			self.x = self.y = self.z = 0;
			self.w = 1;
		};

		Kayac.Q.createIdentity = function () {
			var ret = new Kayac.Q();
			ret.setIdentity();
			return ret;
		};

		Kayac.Q.setRotation = function (self, axisNormalized, angle) {
			var halfAngle = angle * 0.5;
			var s = Math.sin(halfAngle);
			var c = Math.cos(halfAngle);
			self.w = c;
			self.x = s * axisNormalized.x;
			self.y = s * axisNormalized.y;
			self.z = s * axisNormalized.z;
		};

		Kayac.Q.setRotationZMinusToVectorW0 = function (self, v) {
			/*
			(0,0,-1)をv(x,y,z)に回転するクォータニオンを生成する。
			w=0だと回転角は180度に固定される。
			180度回して行けるのだから、回転軸は(0,0,-1)とdの平均ベクタだ。
			平均だから足せばいい。
			= Q(cos(90),sin(90)*x, sin(90)*y, sin(90)*(z-1))
			= Q(0, x, y, z-1)
			となる。角度が固定されるために三角関数を呼ぶ必要ない。
			zに-1を足したせいで長さが1でなくなっているので、正規化する必要がある。
			L=sqrt(x^2+y^2+z^2-2z+1)
			なので、これで割れば良い。この時、x^2+y^2+z^2=1とわかっているため、
			L=sqrt(-2z+2)
			と単純化される
			*/
			var tmp = (-v.z + 1) * 2;
			if (tmp <= 0) { //演算誤差及びz==-1対策
				self.w = self.y = self.z = 0; //x軸180度回転で到達可能
				self.x = 1;
			} else {
				var l = Math.sqrt(tmp);
				var rcpL = 1 / l;
				self.w = 0;
				self.x = v.x * rcpL;
				self.y = v.y * rcpL;
				self.z = (v.z - 1) * rcpL;
			}
		};

		Kayac.Q.setOrientation = function (
			self,
			forwardNormalized,
			upwardNormalized) {

			var V = Kayac.V3; //別名
			var Q = Kayac.Q; //別名
			//上ベクタと前ベクタから右ベクタを生成
			var x = new V();
			V.setCross(x, forwardNormalized, upwardNormalized);
			V.normalize(x);
			//X,-Z軸からYを生成。正規直交なので正規化不要
			var y = new V();
			V.setCross(y, x, forwardNormalized);

			//まず(0,0,-1)をzに回す。計算量を削るためにw0で作る。
			var q0 = new Q();
			Q.setRotationZMinusToVectorW0(q0, forwardNormalized);
			//これでY軸を回す
			var yt = new V3();
			V.setRotated(yt, q0, new V([0, 1, 0]));

			var q1 = new Q();
			var h = new V3();
			V.setAdd(h, yt, y); //まだ正規化はしない
			var crossY = new V();
			V.isetCross(crossY, yt, h);
			var crossYL2 = V.sqMagnitude(crossY);
			if ((crossYL2 < 1e-8) && (V.dot(yt, y) < 0)) {
				q1.w = 0;
				q1.x = forwardNormalized.x;
				q1.y = forwardNormalized.y;
				q1.z = forwardNormalized.z;
			} else {
				var rcpHLength = 1 / h.magnitude();
				q1.w = V.dot(yt, h) * rcpHLength;
				q1.x = crossY.x * rcpHLength;
				q1.y = crossY.y * rcpHLength;
				q1.z = crossY.z * rcpHLength;
			}
			Q.initToMul(self, q1, q0);
		};

		Kayac.Q.add = function (self, a) {
			self.x += a.x;
			self.y += a.y;
			self.z += a.z;
			self.w += a.w;
		};

		Kayac.Q.setAdd = function (a, b) {
			self.x = a.x + b.x;
			self.y = a.y + b.y;
			self.z = a.z + b.z;
			self.w = a.w + b.w;
		};

		Kayac.Q.setMul = function (self, a, b) {
			var x = (a.w * b.x) + (a.x * b.w) + (a.y * b.z) - (a.z * b.y);
			var y = (a.w * b.y) + (a.y * b.w) + (a.z * b.x) - (a.x * b.z);
			var z = (a.w * b.z) + (a.z * b.w) + (a.x * b.y) - (a.y * b.x);
			self.w = (a.w * b.w) - (a.x * b.x) - (a.y * b.y) - (a.z * b.z);
			self.x = x;
			self.y = y;
			self.z = z;
		};

		Kayac.Q.setMulQV = function (self, a, b) {
			//上の関数から不要な項を消している
			var x = (a.w * b.x) + (a.y * b.z) - (a.z * b.y);
			var y = (a.w * b.y) + (a.z * b.x) - (a.x * b.z);
			var z = (a.w * b.z) + (a.x * b.y) - (a.y * b.x);
			self.w = - (a.x * b.x) - (a.y * b.y) - (a.z * b.z);
			self.x = x;
			self.y = y;
			self.z = z;
		};

		Kayac.Q.setMulVQ = function (self, a, b) { //aはV3
			//上の関数から不要な項を消している
			var x = (a.x * b.w) + (a.y * b.z) - (a.z * b.y);
			var y = (a.y * b.w) + (a.z * b.x) - (a.x * b.z);
			var z = (a.z * b.w) + (a.x * b.y) - (a.y * b.x);
			self.w = - (a.x * b.x) - (a.y * b.y) - (a.z * b.z);
			self.x = x;
			self.y = y;
			self.z = z;
		};

		Kayac.Q.mul = function (self, a) {
			Kayac.Q.initToMul(self, self, a);
		};

		Kayac.Q.mulV = function (self, a) {
			Kayac.Q.initToMulQV(self, self, a);
		};

		Kayac.Q.mulVQ = function (self, a) {
			Kayac.Q.initToMulVQ(self, self, a);
		};

		Kayac.Q.sqNorm = function (self) {
			return (self.w * self.w) +
				(self.x * self.x) +
				(self.y * self.y) +
				(self.z * self.z);
		};

		Kayac.Q.norm = function (self) {
			return Math.sqrt(Kayac.Q.sqNorm(self));
		};

		Kayac.Q.normalize = function (self) {
			var n = Kayac.Q.norm(self);
			if (n !== 0) {
				var rcpN = 1 / n;
				self.w *= rcpN;
				self.x *= rcpN;
				self.y *= rcpN;
				self.z *= rcpN;
			}
		};

		Kayac.Q.invert = function (self) {
			self.x = -self.x;
			self.y = -self.y;
			self.z = -self.z;
		};

		Kayac.Q.integrate = function (self, angularVelocity, deltaTime) {
			var tv = new Kayac.V3();
			tv.setMulS(angularVelocity, deltaTime * 0.5);
			var tq = new Kayac.Q();
			tq.setMulQV(self, tv);
			self.add(tq);
			self.normalize();
		};

		//以下メソッド版
		Kayac.Q.prototype.setXyzw = function (x, y, z, w) {
			Kayac.Q.setXyzw(this, x, y, z, w);
		};

		Kayac.Q.prototype.setA = function (a) {
			Kayac.Q.setA(this, a);
		};

		Kayac.Q.prototype.setQ = function (q) {
			Kayac.Q.setQ(this, q);
		};

		Kayac.Q.prototype.setIdentity = function () {
			Kayac.Q.setIdentity(this);
		};

		Kayac.Q.prototype.setRotation = function (axisNormalized, angle) {
			Kayac.Q.setRotation(this, axisNormalized, angle);
		};

		Kayac.Q.prototype.setRotationZMinusToVectorW0 = function (v) {
			Kayac.Q.setRotationZMinusToVectorW0(this, v);
		};

		Kayac.Q.prototype.setOrientation = function (
			forwardNormalized,
			upwardNormalized) {

			Kayac.Q.setOrientation(this, forwardNormalized, upwardNormalized);
		};

		Kayac.Q.prototype.add = function (a) {
			Kayac.Q.add(this, a);
		};

		Kayac.Q.prototype.setAdd = function (a, b) {
			Kayac.Q.setAdd(this, a, b);
		};

		Kayac.Q.prototype.setMul = function (a, b) {
			Kayac.Q.setMul(this, a, b);
		};

		Kayac.Q.prototype.setMulQV = function (a, b) { //bはV3
			Kayac.Q.setMulQV(this, a, b);
		};

		Kayac.Q.prototype.setMulVQ = function (a, b) { //aはV3
			Kayac.Q.setMulVQ(this, a, b);
		};

		Kayac.Q.prototype.mul = function (a) {
			this.setMul(this, a);
		};

		Kayac.Q.prototype.mulV = function (a) {
			this.setMulQV(this, a);
		};

		Kayac.Q.prototype.mulVQ = function (a) {
			this.setMulVQ(a, this);
		};

		Kayac.Q.prototype.sqNorm = function () {
			return Kayac.Q.sqNorm(this);
		};

		Kayac.Q.prototype.norm = function () {
			return Kayac.Q.norm(this);
		};

		Kayac.Q.prototype.normalize = function () {
			Kayac.Q.normalize(this);
		};

		Kayac.Q.prototype.invert = function () {
			Kayac.Q.invert(this);
		};

		Kayac.Q.prototype.integrate = function (angularVelocity, deltaTime) {
			Kayac.Q.integrate(this, angularVelocity, deltaTime);
		};

		//M23
		Kayac.M23 = function () {
		};

		Kayac.M23.prototype.setM = function (m) {
			this.m00 = m.m00;
			this.m01 = m.m01;
			this.m02 = m.m02;
			this.m10 = m.m10;
			this.m11 = m.m11;
			this.m12 = m.m12;
		};

		// 回転角を与えてカメラ行列を生成
		Kayac.M23.prototype.setRotation = function (theta) {
			var s = Math.sin(theta);
			var c = Math.cos(theta);
			this.m00 = c;
			this.m01 = s;
			this.m10 = -s;
			this.m11 = c;
			this.m02 = this.m12 = 0;
		};

		// 前から移動を乗算
		Kayac.M23.prototype.preMultiplyTranslation = function (v) {
			this.m02 += v.x;
			this.m12 += v.y;
		};

		// 後ろから移動を乗算
		Kayac.M23.prototype.postMultiplyTranslation = function (v) {
			this.m02 += (this.m00 * v.x) + (this.m01 * v.y);
			this.m12 += (this.m10 * v.x) + (this.m11 * v.y);
		};

		// 前から拡縮を乗算
		Kayac.M23.prototype.preMultiplyScale = function (v) {
			this.m00 *= v.x;
			this.m01 *= v.x;
			this.m02 *= v.x;
			this.m10 *= v.y;
			this.m11 *= v.y;
			this.m12 *= v.y;
		};

		// 後ろから拡縮を乗算
		Kayac.M23.prototype.postMultiplyScale = function (v) {
			this.m00 *= v.x;
			this.m01 *= v.y;
			this.m10 *= v.x;
			this.m11 *= v.y;
		};

		//M34
		Kayac.M34 = function () {
		};

		Kayac.M34.createM = function (m) {
			var ret = new Kayac.M34();
			ret.copyFrom(m);
			return ret;
		}

		Kayac.M34.setMul = function (out, a, b) {
			var m0 = (a.m00 * b.m00) + (a.m01 * b.m10) + (a.m02 * b.m20);
			var m1 = (a.m00 * b.m01) + (a.m01 * b.m11) + (a.m02 * b.m21);
			var m2 = (a.m00 * b.m02) + (a.m01 * b.m12) + (a.m02 * b.m22);
			var m3 = (a.m00 * b.m03) + (a.m01 * b.m13) + (a.m02 * b.m23) + a.m03;
			out.m00 = m0;
			out.m01 = m1;
			out.m02 = m2;
			out.m03 = m3;

			var m0 = (a.m10 * b.m00) + (a.m11 * b.m10) + (a.m12 * b.m20);
			var m1 = (a.m10 * b.m01) + (a.m11 * b.m11) + (a.m12 * b.m21);
			var m2 = (a.m10 * b.m02) + (a.m11 * b.m12) + (a.m12 * b.m22);
			var m3 = (a.m10 * b.m03) + (a.m11 * b.m13) + (a.m12 * b.m23) + a.m13;
			out.m10 = m0;
			out.m11 = m1;
			out.m12 = m2;
			out.m13 = m3;

			var m0 = (a.m20 * b.m00) + (a.m21 * b.m10) + (a.m22 * b.m20);
			var m1 = (a.m20 * b.m01) + (a.m21 * b.m11) + (a.m22 * b.m21);
			var m2 = (a.m20 * b.m02) + (a.m21 * b.m12) + (a.m22 * b.m22);
			var m3 = (a.m20 * b.m03) + (a.m21 * b.m13) + (a.m22 * b.m23) + a.m23;
			out.m20 = m0;
			out.m21 = m1;
			out.m22 = m2;
			out.m23 = m3;
		};

		Kayac.M34.prototype.setIdentity = function () {
			this.m00 = this.m11 = this.m22 = 1;
			this.m01 = this.m02 = this.m03 = 0;
			this.m10 = this.m12 = this.m13 = 0;
			this.m20 = this.m21 = this.m23 = 0;
		};

		Kayac.M34.prototype.copyFrom = function (a) {
			this.m00 = a.m00;
			this.m01 = a.m01;
			this.m02 = a.m02;
			this.m03 = a.m03;

			this.m10 = a.m10;
			this.m11 = a.m11;
			this.m12 = a.m12;
			this.m13 = a.m13;

			this.m20 = a.m20;
			this.m21 = a.m21;
			this.m22 = a.m22;
			this.m23 = a.m23;
		};

		Kayac.M34.prototype.setM = function (m) {
			this.m00 = m.m00;
			this.m01 = m.m01;
			this.m02 = m.m02;
			this.m03 = m.m03;
			this.m10 = m.m10;
			this.m11 = m.m11;
			this.m12 = m.m12;
			this.m13 = m.m13;
			this.m20 = m.m20;
			this.m21 = m.m21;
			this.m22 = m.m22;
			this.m23 = m.m23;
		};

		Kayac.M34.prototype.mul = function (a) {
			Kayac.M34.setMul(this, this, a);
		};

		Kayac.M34.prototype.setMul = function (a, b) {
			Kayac.M34.setMul(this, a, b);
		};

		Kayac.M34.prototype.setQ = function (q) {
			var xx = q.x * q.x;
			var yy = q.y * q.y;
			var zz = q.z * q.z;
			var xy = q.x * q.y;
			var yz = q.y * q.z;
			var zx = q.z * q.x;
			var xw = q.x * q.w;
			var yw = q.y * q.w;
			var zw = q.z * q.w;

			this.m00 = 1 - (2 * (yy + zz));
			this.m01 = 2 * (xy - zw);
			this.m02 = 2 * (zx + yw);

			this.m10 = 2 * (xy + zw);
			this.m11 = 1 - (2 * (xx + zz));
			this.m12 = 2 * (yz - xw);

			this.m20 = 2 * (zx - yw);
			this.m21 = 2 * (yz + xw);
			this.m22 = 1 - (2 * (xx + yy));

			this.m03 = this.m13 = this.m23 = 0;
		};

		// 前から移動を乗算
		Kayac.M34.prototype.preMultiplyTranslation = function (t) {
			this.m03 += t.x;
			this.m13 += t.y;
			this.m23 += t.z;
		};

		// 後ろから移動を乗算
		Kayac.M34.prototype.postMultiplyTranslation = function (t) {
			this.m03 += (this.m00 * t.x) + (this.m01 * t.y) + (this.m02 * t.z);
			this.m13 += (this.m10 * t.x) + (this.m11 * t.y) + (this.m12 * t.z);
			this.m23 += (this.m20 * t.x) + (this.m21 * t.y) + (this.m22 * t.z);
		};

		// 前から拡縮を乗算
		Kayac.M34.prototype.preMultiplyScale = function (v) {
			this.m00 *= v.x;
			this.m01 *= v.x;
			this.m02 *= v.x;
			this.m03 *= v.x;
			this.m10 *= v.y;
			this.m11 *= v.y;
			this.m12 *= v.y;
			this.m13 *= v.y;
			this.m20 *= v.z;
			this.m21 *= v.z;
			this.m22 *= v.z;
			this.m23 *= v.z;
		};

		// 後ろから拡縮を乗算
		Kayac.M34.prototype.postMultiplyScale = function (v) {
			this.m00 *= v.x;
			this.m01 *= v.y;
			this.m02 *= v.z;
			this.m10 *= v.x;
			this.m11 *= v.y;
			this.m12 *= v.z;
			this.m20 *= v.x;
			this.m21 *= v.y;
			this.m22 *= v.z;
		};

		//M44
		Kayac.M44 = function () {
		};

		Kayac.M44.setMul44x34 = function (out44, m44, m34) {
			var m0 = (m44.m00 * m34.m00) + (m44.m01 * m34.m10) + (m44.m02 * m34.m20);
			var m1 = (m44.m00 * m34.m01) + (m44.m01 * m34.m11) + (m44.m02 * m34.m21);
			var m2 = (m44.m00 * m34.m02) + (m44.m01 * m34.m12) + (m44.m02 * m34.m22);
			var m3 = (m44.m00 * m34.m03) + (m44.m01 * m34.m13) + (m44.m02 * m34.m23) + m44.m03;
			out44.m00 = m0;
			out44.m01 = m1;
			out44.m02 = m2;
			out44.m03 = m3;

			m0 = (m44.m10 * m34.m00) + (m44.m11 * m34.m10) + (m44.m12 * m34.m20);
			m1 = (m44.m10 * m34.m01) + (m44.m11 * m34.m11) + (m44.m12 * m34.m21);
			m2 = (m44.m10 * m34.m02) + (m44.m11 * m34.m12) + (m44.m12 * m34.m22);
			m3 = (m44.m10 * m34.m03) + (m44.m11 * m34.m13) + (m44.m12 * m34.m23) + m44.m13;
			out44.m10 = m0;
			out44.m11 = m1;
			out44.m12 = m2;
			out44.m13 = m3;

			m0 = (m44.m20 * m34.m00) + (m44.m21 * m34.m10) + (m44.m22 * m34.m20);
			m1 = (m44.m20 * m34.m01) + (m44.m21 * m34.m11) + (m44.m22 * m34.m21);
			m2 = (m44.m20 * m34.m02) + (m44.m21 * m34.m12) + (m44.m22 * m34.m22);
			m3 = (m44.m20 * m34.m03) + (m44.m21 * m34.m13) + (m44.m22 * m34.m23) + m44.m23;
			out44.m20 = m0;
			out44.m21 = m1;
			out44.m22 = m2;
			out44.m23 = m3;

			m0 = (m44.m30 * m34.m00) + (m44.m31 * m34.m10) + (m44.m32 * m34.m20);
			m1 = (m44.m30 * m34.m01) + (m44.m31 * m34.m11) + (m44.m32 * m34.m21);
			m2 = (m44.m30 * m34.m02) + (m44.m31 * m34.m12) + (m44.m32 * m34.m22);
			m3 = (m44.m30 * m34.m03) + (m44.m31 * m34.m13) + (m44.m32 * m34.m23) + m44.m33;
			out44.m30 = m0;
			out44.m31 = m1;
			out44.m32 = m2;
			out44.m33 = m3;
		};

		Kayac.M44.prototype.setMul44x34 = function (m44, m34) {
			Kayac.M44.setMul44x34(this, m44, m34);
		};

		Kayac.M44.prototype.mul34 = function (m34) {
			Kayac.M44.setMul44x34(this, this, m34);
		};

		Kayac.M44.prototype.setM = function (m) {
			this.m00 = m.m00;
			this.m01 = m.m01;
			this.m02 = m.m02;
			this.m03 = m.m03;
			this.m10 = m.m10;
			this.m11 = m.m11;
			this.m12 = m.m12;
			this.m13 = m.m13;
			this.m20 = m.m20;
			this.m21 = m.m21;
			this.m22 = m.m22;
			this.m23 = m.m23;
			this.m30 = m.m30;
			this.m31 = m.m31;
			this.m32 = m.m32;
			this.m33 = m.m33;
		};

		Kayac.M44.prototype.setProjectionView = function (fieldOfViewY, aspect, nearZ, farZ, view) {
			var m11 = 1 / Math.tan(fieldOfViewY * 0.5);
			var m00 = m11 * aspect;
			this.m00 = m00 * view.m00;
			this.m01 = m00 * view.m01;
			this.m02 = m00 * view.m02;
			this.m03 = m00 * view.m03;

			this.m10 = m11 * view.m10;
			this.m11 = m11 * view.m11;
			this.m12 = m11 * view.m12;
			this.m13 = m11 * view.m13;

			var m22 = farZ / (farZ - nearZ);
			var m23 = -m22 * nearZ;

			this.m20 = m22 * view.m20;
			this.m21 = m22 * view.m21;
			this.m22 = m22 * view.m22;
			this.m23 = (m22 * view.m23) + m23;

			this.m30 = view.m20;
			this.m31 = view.m21;
			this.m32 = view.m22;
			this.m33 = view.m23;
		};

		Kayac.M44.multiplyPoint = function (vOut, m, v) {
			var tx = (m.m00 * v.x) + (m.m01 * v.y) + (m.m02 * v.z) + m.m03;
			var ty = (m.m10 * v.x) + (m.m11 * v.y) + (m.m12 * v.z) + m.m13;
			var tz = (m.m20 * v.x) + (m.m21 * v.y) + (m.m22 * v.z) + m.m23;
			var w = (m.m30 * v.x) + (m.m31 * v.y) + (m.m32 * v.z) + m.m33;

			var rcpW = 1 / w;
			vOut.x = tx * rcpW;
			vOut.y = ty * rcpW;
			vOut.z = tz * rcpW;
		};

		//その他関数

		//a2*x^2 + a1*x^1 + a0 = 0を解く。
		//解があれば小さな順に並べた2要素配列を返し、
		//解がなければ、nullを返す。
		Kayac.solveQuadratic = function (a2, a1, a0) {
			//倍精度なので小細工はせず、解の公式をそのままつっこむ
			if (a2 === 0) { //2次項0
				if (a1 === 0) { //1次項0。解けないか不定。
					return null;
				} else {
					var x = -a0 / a1;
					return [x, x]; //便宜のために2要素にして返す。
				}
			}
			var d = (a1 * a1) - (4 * a2 * a0);
			if (d < 0) {
				return null;
			}
			d = Math.sqrt(d);
			var x = [];
			x[0] = (-a1 - d) / (2 * a2);
			x[1] = (-a1 + d) / (2 * a2);
			return x;
		};

		//x^2 + a1*x^1 + a0 = 0を解く。2次の係数が1限定。
		//解があれば小さな順に並べた2要素配列を返し、
		//解がなければ、nullを返す。
		Kayac.solveQuadraticSq1 = function (a1, a0) {
			//倍精度なので小細工はせず、解の公式をそのままつっこむ
			var d = (a1 * a1) - (4 * a0);
			if (d < 0) {
				return null;
			}
			d = Math.sqrt(d);
			var x = [];
			x[0] = (-a1 - d) * 0.5;
			x[1] = (-a1 + d) * 0.5;
			return x;
		};
	</script>

	<script id="3dLib">
		var Kayac = Kayac || {};

		// Mesh
		Kayac.Mesh = function (shader, vertexFormat, name) {
			this.name = name || 'unnamed mesh';
			this.mVertexBuffer = null;
			this.mShader = shader;
			this.mVertexFormat = vertexFormat;
			this.mVertexCount = 0;
		};
		Kayac.Mesh.prototype.setCube = function (gpu) {
			var floatStride = this.mVertexFormat.stride / 4;
			var data = new Float32Array(36 * floatStride); //36頂点
			//TODO:
			this.setVertex(data, 0, [-1, -1, -1], [-1, 0, 0], [0, 0]);
			this.setVertex(data, 1, [-1, -1, 1], [-1, 0, 0], [0, 0]);
			this.setVertex(data, 2, [-1, 1, 1], [-1, 0, 0], [0, 0]);
			this.copyVertex(data, 3, 0);
			this.copyVertex(data, 4, 2);
			this.setVertex(data, 5, [-1, 1, -1], [-1, 0, 0], [0, 0]);

			this.setVertex(data, 6, [1, -1, -1], [1, 0, 0], [0, 0]);
			this.setVertex(data, 7, [1, -1, 1], [1, 0, 0], [0, 0]);
			this.setVertex(data, 8, [1, 1, 1], [1, 0, 0], [0, 0]);
			this.copyVertex(data, 9, 6);
			this.copyVertex(data, 10, 8);
			this.setVertex(data, 11, [1, 1, -1], [1, 0, 0], [0, 0]);

			this.setVertex(data, 12, [-1, -1, -1], [0, -1, 0], [0, 0]);
			this.setVertex(data, 13, [-1, -1, 1], [0, -1, 0], [0, 0]);
			this.setVertex(data, 14, [1, -1, 1], [0, -1, 0], [0, 0]);
			this.copyVertex(data, 15, 12);
			this.copyVertex(data, 16, 14);
			this.setVertex(data, 17, [1, -1, -1], [0, -1, 0], [0, 0]);

			this.setVertex(data, 18, [-1, 1, -1], [0, 1, 0], [0, 0]);
			this.setVertex(data, 19, [-1, 1, 1], [0, 1, 0], [0, 0]);
			this.setVertex(data, 20, [1, 1, 1], [0, 1, 0], [0, 0]);
			this.copyVertex(data, 21, 18);
			this.copyVertex(data, 22, 20);
			this.setVertex(data, 23, [1, 1, -1], [0, 1, 0], [0, 0]);

			this.setVertex(data, 24, [-1, -1, -1], [0, 0, -1], [0, 0]);
			this.setVertex(data, 25, [1, -1, -1], [0, 0, -1], [0, 0]);
			this.setVertex(data, 26, [1, 1, -1], [0, 0, -1], [0, 0]);
			this.copyVertex(data, 27, 24);
			this.copyVertex(data, 28, 26);
			this.setVertex(data, 29, [-1, 1, -1], [0, 0, -1], [0, 0]);

			this.setVertex(data, 30, [-1, -1, 1], [0, 0, 1], [0, 0]);
			this.setVertex(data, 31, [1, -1, 1], [0, 0, 1], [0, 0]);
			this.setVertex(data, 32, [1, 1, 1], [0, 0, 1], [0, 0]);
			this.copyVertex(data, 33, 30);
			this.copyVertex(data, 34, 32);
			this.setVertex(data, 35, [-1, 1, 1], [0, 0, 1], [0, 0]);

			this.mVertexBuffer = new Kayac.VertexBuffer({
				gpu: gpu,
				name: this.name + '_vb',
				data: data
			});
			this.mVertexCount = 36;
		};
		Kayac.Mesh.generateVertexFormat = function () {
			var ret = {
				stride: 32,
				elements: [
					{ offset: 0, vectorDimension: 3, name: 'aPosition' },
					{ offset: 12, vectorDimension: 3, name: 'aNormal' },
					{ offset: 24, vectorDimension: 2, name: 'aTexCoord' },
				]
			};
			return ret;
		};
		Kayac.Mesh.prototype.setVertex = function (
			data,
			index,
			position,
			normal,
			texCoord) {

			var offset = index * this.mVertexFormat.stride / 4;
			Kayac.copyArray(data, offset + 0, position, 0, 3);
			Kayac.copyArray(data, offset + 3, normal, 0, 3);
			Kayac.copyArray(data, offset + 6, texCoord, 0, 2);
		};
		Kayac.Mesh.prototype.copyVertex = function (data, dstIndex, srcIndex) {
			var floatStride = this.mVertexFormat.stride / 4;
			var dst = dstIndex * floatStride;
			var src = srcIndex * floatStride;
			Kayac.copyArray(data, dst, data, src, floatStride);
		};
		Kayac.Mesh.prototype.draw = function (gpu, pvwMatrix, wMatrix) {
			gpu.setVertexBuffer(this.mVertexBuffer);
			gpu.setShader(this.mShader);
			gpu.setVertexFormat(this.mVertexFormat);

			var m = pvwMatrix; // 別名
			gpu.setConstant('transform0', [m.m00, m.m01, m.m02, m.m03]);
			gpu.setConstant('transform1', [m.m10, m.m11, m.m12, m.m13]);
			gpu.setConstant('transform2', [m.m20, m.m21, m.m22, m.m23]);
			gpu.setConstant('transform3', [m.m30, m.m31, m.m32, m.m33]);
			m = wMatrix; // 別名
			gpu.setConstant('toWorld0', [m.m00, m.m01, m.m02]);
			gpu.setConstant('toWorld1', [m.m10, m.m11, m.m12]);
			gpu.setConstant('toWorld2', [m.m20, m.m21, m.m22]);
			// TODO: ライトパラメタ
			gpu.draw(this.mVertexCount, Kayac.Gpu.Primitive.Triangle, 0);
		};

		// Camera3d
		Kayac.Camera3d = function () {
			this.fieldOfViewY = Math.PI / 6; //初期値60度
			this.aspect = 1;
			this.position = [0, 0, 0]; //原点配置
			this.rotation = new Kayac.Q();
			this.rotation.setXyzw(0, 0, 0, 1);
			this.nearClip = 1;
			this.farClip = 1000;
		};

		Kayac.Camera3d.prototype.getMatrix = function () {
			var view = new Kayac.M34();
			var invR = new Kayac.Q();
			invR.setQ(this.rotation);
			invR.invert();
			view.setQ(invR); // まず回転行列設定
			var invT = new Kayac.V3();
			invT.setA(this.position);
			invT.neg();
			view.postMultiplyTranslation(invT); // 後ろから逆移動を乗算

			var ret = new Kayac.M44();
			ret.setProjectionView(this.fieldOfViewY, this.aspect, this.nearClip, this.farClip, view);
			return ret;
		};

		// Camera2d
		Kayac.Camera2d = function () {
			this.aspect = 1;
			this.position = [0, 0]; //原点配置
			this.rotation = 0;
			this.projectionScale = [1, 1];
		};
		Kayac.Camera2d.prototype.setProjection = function (width, height) {
			this.projectionScale = [2.0 / width, 2.0 / height];
		};

		//M23を返す
		Kayac.Camera2d.prototype.getMatrix = function () {
			var ret = new Kayac.M23();
			ret.setRotation(-this.rotation); // 逆回転
			var invT = new Kayac.V2();
			invT.setA(this.position);
			invT.neg();
			ret.postMultiplyTranslation(invT); // 後ろから逆移動を乗算
			var scale = new Kayac.V2();
			scale.setA(this.projectionScale);
			ret.preMultiplyScale(scale); // 前から拡縮を乗算
			return ret;
		};

		// Sprite
		Kayac.Sprite = function () {
			this.name = 'unnamed sprite';
			this.position = [0, 0];
			this.size = [1, 1];
			this.texture = null;
			this.texcoordOffset = [0, 0];
			this.texcoordScale = [1, 1];
		};

		// SpriteRenderer
		Kayac.SpriteRenderer = function (
			gpu,
			spriteCapacity,
			vertexFormat,
			shader) {

			var stride = vertexFormat.stride;
			var vertexBufferSize = spriteCapacity * 6 * stride;
			this.mSprites = [];
			this.mGpu = gpu;
			this.mShader = shader;
			this.mVertexFormat = vertexFormat;
			this.mVertexBuffer = new Kayac.VertexBuffer({ gpu: gpu, name: 'spriteRendererVb', size: vertexBufferSize });
		};
		Kayac.SpriteRenderer.prototype.clear = function () {
			this.mSprites = [];
		};
		Kayac.SpriteRenderer.prototype.add = function (sprite) {
			this.mSprites.push(sprite);
		};
		Kayac.SpriteRenderer.prototype.draw = function (gpu, cameraMatrix) {
			// 全頂点バッファを生成
			var floatStride = this.mVertexFormat.stride / 4;
			var buffer = new Float32Array(this.mSprites.length * 6 * floatStride);
			var offset = 0;
			for (var i = 0; i < this.mSprites.length; i++) {
				var sprite = this.mSprites[i];
				// 右下
				buffer[offset + 0] = sprite.position[0] + sprite.size[0];
				buffer[offset + 1] = sprite.position[1] + sprite.size[1];
				buffer[offset + 2] = sprite.texcoordOffset[0] + sprite.texcoordScale[0];
				buffer[offset + 3] = sprite.texcoordOffset[1] - sprite.texcoordScale[1];
				offset += floatStride;

				// 右上
				buffer[offset + 0] = sprite.position[0] + sprite.size[0];
				buffer[offset + 1] = sprite.position[1];
				buffer[offset + 2] = sprite.texcoordOffset[0] + sprite.texcoordScale[0];
				buffer[offset + 3] = sprite.texcoordOffset[1];
				offset += floatStride;

				// 左下
				buffer[offset + 0] = sprite.position[0];
				buffer[offset + 1] = sprite.position[1] + sprite.size[1];
				buffer[offset + 2] = sprite.texcoordOffset[0];
				buffer[offset + 3] = sprite.texcoordOffset[1] - sprite.texcoordScale[1];
				offset += floatStride;

				// 左下
				buffer[offset + 0] = buffer[offset - 4];
				buffer[offset + 1] = buffer[offset - 3];
				buffer[offset + 2] = buffer[offset - 2];
				buffer[offset + 3] = buffer[offset - 1];
				offset += floatStride;

				// 右上
				buffer[offset + 0] = buffer[offset - 12];
				buffer[offset + 1] = buffer[offset - 11];
				buffer[offset + 2] = buffer[offset - 10];
				buffer[offset + 3] = buffer[offset - 9];
				offset += floatStride;

				// 左上
				buffer[offset + 0] = sprite.position[0];
				buffer[offset + 1] = sprite.position[1];
				buffer[offset + 2] = sprite.texcoordOffset[0];
				buffer[offset + 3] = sprite.texcoordOffset[1];
				offset += floatStride;
			}
			this.mVertexBuffer.update(buffer.buffer);

			// 描画 TODO: DrawCallのマージ
			gpu.setVertexBuffer(this.mVertexBuffer);
			gpu.setShader(this.mShader);
			gpu.setVertexFormat(this.mVertexFormat);
			gpu.setConstant('transform0', [cameraMatrix.m00, cameraMatrix.m01, cameraMatrix.m02]);
			gpu.setConstant('transform1', [cameraMatrix.m10, cameraMatrix.m11, cameraMatrix.m12]);
			for (var i = 0; i < this.mSprites.length; i++) {
				gpu.setTexture('uSampler', this.mSprites[i].texture); // あとで
				gpu.draw(6, Kayac.Gpu.Primitive.Triangle, i * 6);
			}
		};

		Kayac.Transform = function () {
			this.name = 'unnamed transform';
			this.position = Kayac.V3.createXyz(0, 0, 0);
			this.rotation = Kayac.Q.createIdentity();
			this.scale = Kayac.V3.createXyz(1, 1, 1);
		};

		// M34を返す
		Kayac.Transform.prototype.getMatrix = function () {
			var ret = new Kayac.M34();
			ret.setQ(this.rotation); // 回転
			ret.preMultiplyTranslation(this.position); // 前から移動を乗算
			ret.postMultiplyScale(this.scale); // 後ろから拡縮を乗算
			return ret;
		};

		// MatrixStack
		Kayac.MatrixStack = function () {
			this.mStack = [];
			var bottom = new Kayac.M34();
			bottom.setIdentity();
			this.mStack.push(bottom);
			this.mTop = 0;
		};
		Kayac.MatrixStack.reset = function () {
			this.mTop = 0;
		};
		Kayac.MatrixStack.prototype.push = function () {
			var top = this.mTop;
			this.mStack[top + 1] = Kayac.M34.createM(this.mStack[top]);
			this.mTop += 1;
		};
		Kayac.MatrixStack.prototype.pop = function () {
			console.assert(this.mTop > 0);
			this.mTop -= 1;
		};
		Kayac.MatrixStack.prototype.pushMul = function (m) {
			this.push();
			this.mStack[this.mTop].mul(m);
		};
		Kayac.MatrixStack.prototype.top = function () {
			return this.mStack[this.mTop];
		};
	</script>

	<script>
		var uiAtlas = {
			"items": [
				{
					"name": "result_text_cyoubiun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 4
				},
				{
					"name": "result_text_cyubiun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 228
				},
				{
					"name": "result_text_cyubsyuuun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 452
				},
				{
					"name": "result_text_daibiun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 676
				},
				{
					"name": "result_text_daibsyuuun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 900
				},
				{
					"name": "result_text_keisoku",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 1124
				},
				{
					"name": "result_text_syobiun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 1348
				},
				{
					"name": "result_text_syobsyuuun",
					"width": 604,
					"height": 220,
					"x": 4,
					"y": 1572
				},
				{
					"name": "title",
					"width": 570,
					"height": 146,
					"x": 4,
					"y": 1796
				},
				{
					"name": "text_setsumei",
					"width": 536,
					"height": 224,
					"x": 4,
					"y": 1946
				},
				{
					"name": "result_text01",
					"width": 450,
					"height": 50,
					"x": 544,
					"y": 1946
				},
				{
					"name": "result_text03",
					"width": 418,
					"height": 50,
					"x": 4,
					"y": 2174
				},
				{
					"name": "text_middle",
					"width": 416,
					"height": 180,
					"x": 426,
					"y": 2174
				},
				{
					"name": "btm_start",
					"width": 410,
					"height": 84,
					"x": 4,
					"y": 2358
				},
				{
					"name": "result_text02",
					"width": 350,
					"height": 50,
					"x": 418,
					"y": 2358
				},
				{
					"name": "btm_tap",
					"width": 256,
					"height": 256,
					"x": 4,
					"y": 2446
				},
				{
					"name": "text_top",
					"width": 256,
					"height": 180,
					"x": 264,
					"y": 2446
				},
				{
					"name": "result",
					"width": 250,
					"height": 58,
					"x": 524,
					"y": 2446
				},
				{
					"name": "result_balance_beautiful",
					"width": 218,
					"height": 42,
					"x": 778,
					"y": 2446
				},
				{
					"name": "result_balance",
					"width": 180,
					"height": 42,
					"x": 4,
					"y": 2706
				},
				{
					"name": "result_size_medium",
					"width": 160,
					"height": 42,
					"x": 188,
					"y": 2706
				},
				{
					"name": "result_size_small",
					"width": 148,
					"height": 42,
					"x": 352,
					"y": 2706
				},
				{
					"name": "result_size_large",
					"width": 138,
					"height": 42,
					"x": 504,
					"y": 2706
				},
				{
					"name": "result_balance_ugly",
					"width": 126,
					"height": 42,
					"x": 646,
					"y": 2706
				},
				{
					"name": "result_size",
					"width": 100,
					"height": 42,
					"x": 776,
					"y": 2706
				},
				{
					"name": "result_flame",
					"width": 40,
					"height": 40,
					"x": 880,
					"y": 2706
				}
			],
			"width": 1024,
			"height": 4096
		};
	</script>

	<script>
		var canvasWidth = 432; // 仮
		var canvasHeight = 768; // 仮
		var Scene = {
			Loading: 0,
			Title: 1,
			Game: 2,
			Result: 3
		};
		//フレームをまたいで保持するデータ
		var state = {
			gpu: null,
			camera2d: null,
			camera3d: null,
			vertexFormat3d: null,
			vertexFormat2d: null,
			shader3d: null,
			shader2d: null,
			renderTexture: null,
			renderTarget: null,
			backgroundSprite: null,
			bgSprites: null,
			spriteRenderer: null,
			down: false,
			cursorPos: { x: 0, y: 0 },
			textures: {},
			loadingTextureCount: -1,
			time: null,
			bottomMesh: null,
			middleMesh: null,
			topMesh: null,
			matrixStack: null,
			unkoTransform: null,
			bottomTransform: null,
			middleTransform: null,
			topTransform: null,
			deltaTime: 0,
			scene: Scene.Loading
		};

		var initializeGpu = function (canvas) {
			canvas.width = canvasWidth;
			canvas.height = canvasHeight;
			state.gpu = new Kayac.Gpu({ canvas: canvas });
			state.gpu.setFaceCullingEnabled(false); // TODO: 後で戻した方が性能は上がるが誤差だろうたぶん
			state.shader3d = new Kayac.Shader({
				gpu: state.gpu,
				name: 'shader3d',
				vertexShaderId: '3dvs',
				fragmentShaderId: '3dfs'
			});
			state.vertexFormat3d = Kayac.Mesh.generateVertexFormat();
			state.shader2d = new Kayac.Shader({
				gpu: state.gpu,
				name: 'shader2d',
				vertexShaderId: '2dvs',
				fragmentShaderId: '2dfs'
			});
			state.vertexFormat2d = {
				stride: 16,
				elements: [
					{ offset: 0, vectorDimension: 2, name: 'aPosition' },
					{ offset: 8, vectorDimension: 2, name: 'aTexCoord' }
				]
			};
			state.spriteRenderer = new Kayac.SpriteRenderer(state.gpu, 32, state.vertexFormat2d, state.shader2d);
			state.bottomMesh = new Kayac.Mesh(state.shader3d, state.vertexFormat3d, 'unkoBottom');
			state.bottomMesh.setCube(state.gpu);
			state.middleMesh = new Kayac.Mesh(state.shader3d, state.vertexFormat3d, 'middleBottom');
			state.middleMesh.setCube(state.gpu);
			state.topMesh = new Kayac.Mesh(state.shader3d, state.vertexFormat3d, 'topBottom');
			state.topMesh.setCube(state.gpu);
		};
		var mainLoop = function () {
			if (state.loadingTextureCount == 0) {
				state.loadingTextureCount = -1;
				startAfterLoad();
			}
			update();
			draw();
			window.requestAnimationFrame(mainLoop);
		};
		var startBeforeLoad = function () {
			state.time = Date.now();
			state.camera3d = new Kayac.Camera3d();
			state.camera3d.position = [0, 0, -10];
			state.camera3d.farClip = 100;
			state.camera2d = new Kayac.Camera2d();
			state.camera2d.setProjection(canvasWidth, canvasHeight);
			state.camera2d.position = [canvasWidth / 2, canvasHeight / 2];
			startLoad();
		};
		var startLoad = function () {
			state.loadingTextureCount = 2;
			var onImageLoad = function (image) {
				var arg = {
					gpu: state.gpu,
					name: image.name,
					data: image.data,
					width: image.width,
					height: image.height,
					mipmap: true
				};
				var texture = new Kayac.Texture(arg);
				state.textures[image.name] = texture;
				state.loadingTextureCount -= 1;
			};
			Kayac.startLoadImage('bg.png', 'bg', onImageLoad);
			Kayac.startLoadImage('uiAtlas.png', 'uiAtlas', onImageLoad);
		};
		var startAfterLoad = function () {
			// 背景
			var backSprite = new Kayac.Sprite();
			backSprite.name = 'background';
			backSprite.texture = state.textures['bg'];
			backSprite.position = [0, 0];
			backSprite.size = [canvasWidth, canvasHeight];
			backSprite.texcoordScale = [2, 4 * canvasHeight / canvasWidth];
			state.backgroundSprite = backSprite;

			state.scene = Scene.Title;
			// ウンコ初期化
			state.matrixStack = new Kayac.MatrixStack();
			state.unkoTransform = new Kayac.Transform();

			state.bottomTransform = new Kayac.Transform();
			state.middleTransform = new Kayac.Transform();
			state.topTransform = new Kayac.Transform();

			state.bottomTransform.position = Kayac.V3.createXyz(0, -1, 0);
			state.bottomTransform.scale = Kayac.V3.createXyz(1, 1 / 3, 1);

			state.middleTransform.scale = Kayac.V3.createXyz(1, 1 / 3, 1);

			state.topTransform.position = Kayac.V3.createXyz(0, 1, 0);
			state.topTransform.scale = Kayac.V3.createXyz(1, 1 / 3, 1);

			// UI系初期化
			state.uiSprites = {};
			var uiItems = uiAtlas.items;
			var uiTexture = state.textures['uiAtlas'];
			for (var i = 0; i < uiItems.length; i++){
				var item = uiItems[i];
				var sprite = new Kayac.Sprite();
				sprite.name = item.name;
				sprite.texture = uiTexture;
				sprite.size = [item.width, item.height];
				sprite.texcoordScale = [1 / uiAtlas.width, 1 / uiAtlas.height];
				sprite.texcoordOffset = [item.x / uiAtlas.width, 1 - (item.y / uiAtlas.height)];
				uiSprites[sprite.name] = sprite;
			}
		};
		var update = function () {
			var now = Date.now();
			state.deltaTime = (now - state.time) * 0.001;
			state.time = now;
			if (state.scene !== Scene.Loading) {
				var av = new Kayac.V3();
				av.setA([1, 2, 3]);
				state.unkoTransform.rotation.integrate(av, state.deltaTime);
				if (state.scene === Scene.Title) {
					var s = Math.sin(state.time * 0.001);
					state.topTransform.scale = Kayac.V3.createXyz(s, 1 / 3, s);
					s = Math.sin(state.time * 0.0005);
					state.middleTransform.scale = Kayac.V3.createXyz(s, 1 / 3, s);
					s = Math.sin(state.time * 0.00075);
					state.bottomTransform.scale = Kayac.V3.createXyz(s, 1 / 3, s);
				}
			}
		};
		var draw = function () {
			if (state.scene === Scene.Loading) {
				drawLoading();
			} else {
				state.gpu.clear(1, 0, 1, 1); // まずクリア。バグってるかわかるように派手ピンクで塗る
				var camera2dMatrix = state.camera2d.getMatrix();
				// 背景
				drawBackground(camera2dMatrix);
				// ウンコ
				var camera3dMatrix = state.camera3d.getMatrix();
				drawUnko(camera3dMatrix);

				state.gpu.setBlendEnabled(true); // アルファブレンド
				state.gpu.setDepthTest(false, false); // Zテストしないし書き込まない
				state.spriteRenderer.clear();
				if (state.scene === Scene.Title){
					var sprite = state.uiSprites['btm_start']
					state.spriteRenderer.add(sprite);
				}
				state.spriteRenderer.draw(state.gpu, camera2dMatrix);
			}
		};
		var drawLoading = function () {
			state.gpu.clear(1, 1, 1, 1);
			// TODO: 社ロゴとか出すのかな
		};
		var drawUnko = function (camera3dMatrix) {
			// 後で半透明不透明で分岐がいる
			state.gpu.setBlendEnabled(false); // とりあえずアルファブレンド不要
			state.gpu.setDepthTest(true, true);
			var pvwm = new Kayac.M44();
			var m = state.unkoTransform.getMatrix();
			state.matrixStack.pushMul(m);

			drawMesh(pvwm, state.bottomTransform, state.bottomMesh, camera3dMatrix);
			drawMesh(pvwm, state.middleTransform, state.middleMesh, camera3dMatrix);
			drawMesh(pvwm, state.topTransform, state.topMesh, camera3dMatrix);
			state.matrixStack.pop();
		};
		var drawMesh = function (pvwm, transform, mesh, pvm) {
			var m = transform.getMatrix();
			state.matrixStack.pushMul(m);
			var wm = state.matrixStack.top();
			pvwm.setMul44x34(pvm, wm);
			state.topMesh.draw(state.gpu, pvwm, wm);
			state.matrixStack.pop();
		};
		var drawBackground = function (camera2dMatrix) {
			if (state.backgroundSprite !== null) {
				Kayac.add2(state.backgroundSprite.texcoordOffset, [state.deltaTime, state.deltaTime]);
				state.gpu.setBlendEnabled(false); // アルファブレンド不要
				state.gpu.setDepthTest(false, false); // Zテストしないし書き込まない
				state.spriteRenderer.clear();
				state.spriteRenderer.add(state.backgroundSprite);
				state.spriteRenderer.draw(state.gpu, camera2dMatrix);
			}
		};
		var onMouseDown = function (e) {
			e = e || window.event;
			state.down = true;
			state.cursorPos = { x: e.clientX, y: e.clientY };
			e.preventDefault();
			e.stopPropagation;
		};
		var onMouseMove = function (e) {
			e = e || window.event;
			if (state.down) {
				state.cursorPos = { x: e.clientX, y: e.clientY };
			}
			e.preventDefault();
			e.stopPropagation;
		};
		var onMouseLeave = function (e) {
			e = e || window.event;
			state.down = false;
			e.preventDefault();
			e.stopPropagation;
		};
		var onMouseUp = function (e) {
			e = e || window.event;
			state.down = false;
			e.preventDefault();
			e.stopPropagation;
		};
		var onTouchStart = function (e) {
			e = e || window.event;
			if (e.changedTouches.length > 0) {
				state.down = true;
				var touch = e.changedTouches[0];
				state.cursorPos = { x: touch.clientX, y: touch.clientY };
			}
			e.preventDefault();
			e.stopPropagation;
		};
		var onTouchMove = function (e) {
			e = e || window.event;
			if (e.changedTouches.length > 0) {
				var touch = e.changedTouches[0];
				state.cursorPos = { x: touch.clientX, y: touch.clientY };
			}
			e.preventDefault();
			e.stopPropagation;
		};
		var onTouchEnd = function (e) {
			e = e || window.event;
			state.down = false;
			e.preventDefault();
			e.stopPropagation;
		};
		var canvas = document.getElementById('screen');
		canvas.addEventListener('mousedown', onMouseDown, false);
		canvas.addEventListener('mousemove', onMouseMove, false);
		canvas.addEventListener('mouseup', onMouseUp, false);
		canvas.addEventListener('mouseleave', onMouseLeave, false);
		canvas.addEventListener('touchstart', onTouchStart, false);
		canvas.addEventListener('touchmove', onTouchMove, false);
		canvas.addEventListener('touchend', onTouchEnd, false);
		initializeGpu(canvas);
		startBeforeLoad();
		mainLoop();
	</script>
</body>

</html>